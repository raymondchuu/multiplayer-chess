{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createEmotion = _interopRequireDefault(require(\"create-emotion\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _createCSSKey = _interopRequireDefault(require(\"../createCSSKey\"));\n\nvar _EventSpy = _interopRequireDefault(require(\"../EventSpy\"));\n\nvar _FunctionContext = _interopRequireDefault(require(\"./FunctionContext\"));\n\nvar _InternalContext = _interopRequireDefault(require(\"./InternalContext\"));\n\nvar _SpineTo = _interopRequireDefault(require(\"../SpineTo\"));\n\nvar _StateContext = _interopRequireDefault(require(\"./StateContext\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar MIN_CHECK_INTERVAL = 17; // 1 frame\n\nvar MODE_BOTTOM = 'bottom';\nvar MODE_TOP = 'top';\nvar NEAR_END_THRESHOLD = 1;\nvar SCROLL_DECISION_DURATION = 34; // 2 frames\n// We pool the emotion object by nonce.\n// This is to make sure we don't generate too many unneeded <style> tags.\n\nvar emotionPool = {};\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState(_ref) {\n  var mode = _ref.mode,\n      _ref$target = _ref.target,\n      offsetHeight = _ref$target.offsetHeight,\n      scrollHeight = _ref$target.scrollHeight,\n      scrollTop = _ref$target.scrollTop;\n  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  var atTop = scrollTop < NEAR_END_THRESHOLD;\n  var atEnd = mode === MODE_TOP ? atTop : atBottom;\n  var atStart = mode !== MODE_TOP ? atTop : atBottom;\n  return {\n    atBottom: atBottom,\n    atEnd: atEnd,\n    atStart: atStart,\n    atTop: atTop\n  };\n}\n\nfunction isEnd(scrollTop, mode) {\n  return mode === MODE_TOP && scrollTop === 0 || mode === MODE_BOTTOM && scrollTop === '100%';\n}\n\nvar Composer = function Composer(_ref2) {\n  var checkInterval = _ref2.checkInterval,\n      children = _ref2.children,\n      debounce = _ref2.debounce,\n      mode = _ref2.mode,\n      nonce = _ref2.nonce;\n  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;\n  var ignoreScrollEventBeforeRef = (0, _react.useRef)(0);\n\n  var _useState = (0, _react.useState)(mode === MODE_TOP ? 0 : '100%'),\n      _useState2 = _slicedToArray(_useState, 2),\n      scrollTop = _useState2[0],\n      setScrollTop = _useState2[1];\n\n  var _useState3 = (0, _react.useState)(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      target = _useState4[0],\n      setTarget = _useState4[1]; // Internal context\n\n\n  var _useState5 = (0, _react.useState)(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      offsetHeight = _useState6[0],\n      setOffsetHeight = _useState6[1];\n\n  var _useState7 = (0, _react.useState)(0),\n      _useState8 = _slicedToArray(_useState7, 2),\n      scrollHeight = _useState8[0],\n      setScrollHeight = _useState8[1]; // State context\n\n\n  var _useState9 = (0, _react.useState)(false),\n      _useState10 = _slicedToArray(_useState9, 2),\n      animating = _useState10[0],\n      setAnimating = _useState10[1];\n\n  var _useState11 = (0, _react.useState)(true),\n      _useState12 = _slicedToArray(_useState11, 2),\n      atBottom = _useState12[0],\n      setAtBottom = _useState12[1];\n\n  var _useState13 = (0, _react.useState)(true),\n      _useState14 = _slicedToArray(_useState13, 2),\n      atEnd = _useState14[0],\n      setAtEnd = _useState14[1];\n\n  var _useState15 = (0, _react.useState)(true),\n      _useState16 = _slicedToArray(_useState15, 2),\n      atTop = _useState16[0],\n      setAtTop = _useState16[1];\n\n  var _useState17 = (0, _react.useState)(false),\n      _useState18 = _slicedToArray(_useState17, 2),\n      atStart = _useState18[0],\n      setAtStart = _useState18[1];\n\n  var _useState19 = (0, _react.useState)(true),\n      _useState20 = _slicedToArray(_useState19, 2),\n      sticky = _useState20[0],\n      setSticky = _useState20[1]; // High-rate state context\n\n\n  var scrollPositionObserversRef = (0, _react.useRef)([]);\n  var observeScrollPosition = (0, _react.useCallback)(function (fn) {\n    scrollPositionObserversRef.current.push(fn);\n    target && fn({\n      scrollTop: target.scrollTop\n    });\n    return function () {\n      var scrollPositionObservers = scrollPositionObserversRef.current;\n      var index = scrollPositionObservers.indexOf(fn);\n      ~index && scrollPositionObservers.splice(index, 1);\n    };\n  }, [scrollPositionObserversRef, target]);\n  var handleScrollEnd = (0, _react.useCallback)(function () {\n    ignoreScrollEventBeforeRef.current = Date.now();\n    setAnimating(false);\n    setScrollTop(null);\n  }, [ignoreScrollEventBeforeRef, setAnimating, setScrollTop]); // Function context\n\n  var scrollTo = (0, _react.useCallback)(function (scrollTop) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        behavior = _ref3.behavior;\n\n    if (behavior === 'auto') {\n      // Stop any existing animation\n      handleScrollEnd(); // Jump to the scroll position\n\n      target.scrollTop = scrollTop === '100%' ? target.scrollHeight - target.offsetHeight : scrollTop;\n    } else {\n      behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollTo\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n      setAnimating(true);\n      setScrollTop(scrollTop);\n    }\n  }, [handleScrollEnd, setAnimating, setScrollTop, target]);\n  var scrollToBottom = (0, _react.useCallback)(function () {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        behavior = _ref4.behavior;\n\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToBottom\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    scrollTo('100%', {\n      behavior: behavior || 'smooth'\n    });\n  }, [scrollTo]);\n  var scrollToTop = (0, _react.useCallback)(function () {\n    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        behavior = _ref5.behavior;\n\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToTop\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    scrollTo(0, {\n      behavior: behavior || 'smooth'\n    });\n  }, [scrollTo]);\n  var scrollToEnd = (0, _react.useCallback)(function () {\n    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        behavior = _ref6.behavior;\n\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToEnd\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    var options = {\n      behavior: behavior || 'smooth'\n    };\n    mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);\n  }, [mode, scrollToBottom, scrollToTop]);\n  var scrollToStart = (0, _react.useCallback)(function () {\n    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        behavior = _ref7.behavior;\n\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToStart\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    var options = {\n      behavior: behavior || 'smooth'\n    };\n    mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);\n  }, [mode, scrollToBottom, scrollToTop]);\n  (0, _react.useEffect)(function () {\n    if (sticky) {\n      var stickyButNotAtEndSince = false;\n      var timeout = setImmediateInterval(function () {\n        if (sticky && target && !computeViewState({\n          mode: mode,\n          target: target\n        }).atEnd) {\n          if (!stickyButNotAtEndSince) {\n            stickyButNotAtEndSince = Date.now();\n          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n            // Quirks: In Firefox, after user scroll down, Firefox do two things:\n            //         1. Set to a new \"scrollTop\"\n            //         2. Fire \"scroll\" event\n            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n            !animating && scrollToEnd({\n              behavior: 'smooth'\n            });\n            stickyButNotAtEndSince = false;\n          }\n        } else {\n          stickyButNotAtEndSince = false;\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);\n      return function () {\n        return clearInterval(timeout);\n      };\n    }\n  }, [animating, checkInterval, mode, scrollToEnd, sticky, target]);\n  var handleScroll = (0, _react.useCallback)(function (_ref8) {\n    var timeStampLow = _ref8.timeStampLow; // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n    // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n    if (timeStampLow <= ignoreScrollEventBeforeRef.current) {\n      // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n      // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n      return;\n    }\n\n    if (target) {\n      var _computeViewState = computeViewState({\n        mode: mode,\n        target: target\n      }),\n          _atBottom = _computeViewState.atBottom,\n          _atEnd = _computeViewState.atEnd,\n          _atStart = _computeViewState.atStart,\n          _atTop = _computeViewState.atTop;\n\n      setAtBottom(_atBottom);\n      setAtEnd(_atEnd);\n      setAtStart(_atStart);\n      setAtTop(_atTop); // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n      // We need to ignore these \"synthetic\" events\n      // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n      //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom\n\n      var nextOffsetHeight = target.offsetHeight,\n          nextScrollHeight = target.scrollHeight;\n      var offsetHeightChanged = nextOffsetHeight !== offsetHeight;\n      var scrollHeightChanged = nextScrollHeight !== scrollHeight;\n      offsetHeightChanged && setOffsetHeight(nextOffsetHeight);\n      scrollHeightChanged && setScrollHeight(nextScrollHeight); // Sticky means:\n      // - If it is scrolled programatically, we are still in sticky mode\n      // - If it is scrolled by the user, then sticky means if we are at the end\n      // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n\n      !offsetHeightChanged && !scrollHeightChanged && setSticky( // We are sticky if we are animating to the end, or we are already at the end.\n      // We can be \"animating but not sticky\" by calling \"scrollTo(100)\" where the container scrollHeight is 200px.\n      animating && isEnd(scrollTop, mode) || _atEnd); // If no scrollTop is set (not in programmatic scrolling mode), we should set \"animating\" to false\n      // \"animating\" is used to calculate the \"sticky\" property\n\n      scrollTop === null && setAnimating(false);\n      var actualScrollTop = target.scrollTop;\n      scrollPositionObserversRef.current.forEach(function (observer) {\n        return observer({\n          scrollTop: actualScrollTop\n        });\n      });\n    }\n  }, [animating, ignoreScrollEventBeforeRef, mode, offsetHeight, scrollHeight, scrollPositionObserversRef, scrollTop, setAnimating, setAtBottom, setAtEnd, setAtStart, setAtTop, setOffsetHeight, setScrollHeight, setSticky, target]);\n  var styleToClassName = (0, _react.useMemo)(function () {\n    var emotion = emotionPool[nonce] || (emotionPool[nonce] = (0, _createEmotion.default)({\n      key: \"react-scroll-to-bottom--css-\".concat((0, _createCSSKey.default)()),\n      nonce: nonce\n    }));\n    return function (style) {\n      return emotion.css(style) + '';\n    };\n  }, [nonce]);\n  var internalContext = (0, _react.useMemo)(function () {\n    return {\n      observeScrollPosition: observeScrollPosition,\n      offsetHeight: offsetHeight,\n      scrollHeight: scrollHeight,\n      setTarget: setTarget,\n      styleToClassName: styleToClassName\n    };\n  }, [observeScrollPosition, offsetHeight, scrollHeight, setTarget, styleToClassName]);\n  var animatingToEnd = animating && isEnd(scrollTop, mode);\n  var stateContext = (0, _react.useMemo)(function () {\n    return {\n      animating: animating,\n      animatingToEnd: animatingToEnd,\n      atBottom: atBottom,\n      atEnd: atEnd,\n      atStart: atStart,\n      atTop: atTop,\n      mode: mode,\n      sticky: sticky\n    };\n  }, [animating, animatingToEnd, atBottom, atEnd, atStart, atTop, mode, sticky]);\n  var functionContext = (0, _react.useMemo)(function () {\n    return {\n      scrollTo: scrollTo,\n      scrollToBottom: scrollToBottom,\n      scrollToEnd: scrollToEnd,\n      scrollToStart: scrollToStart,\n      scrollToTop: scrollToTop\n    };\n  }, [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]);\n  (0, _react.useEffect)(function () {\n    // We need to update the \"scrollHeight\" value to latest when the user do a focus inside the box.\n    //\n    // This is because:\n    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether \"scrollHeight\" value is latest or not.\n    // - That code only run on \"scroll\" event.\n    // - That means, on every \"scroll\" event, if the \"scrollHeight\" value is not latest, we will skip modifying the stickiness.\n    // - That means, if the user \"focus\" to an element that cause the scroll view to scroll to the bottom, the user agent will fire \"scroll\" event.\n    //   Since the \"scrollHeight\" is not latest value, this \"scroll\" event will be ignored and stickiness will not be modified.\n    // - That means, if the user \"focus\" to a newly added element that is at the end of the scroll view, the \"scroll to bottom\" button will continue to show.\n    //\n    // Repro in Chrome:\n    // 1. Fill up a scroll view\n    // 2. Scroll up, the \"scroll to bottom\" button should show up\n    // 3. Click \"Add a button\"\n    // 4. Click on the scroll view (to pseudo-focus on it)\n    // 5. Press TAB, the scroll view will be at the bottom\n    //\n    // Expect:\n    // - The \"scroll to bottom\" button should be gone.\n    if (target) {\n      var handleFocus = function handleFocus() {\n        return setScrollHeight(target.scrollHeight);\n      };\n\n      target.addEventListener('focus', handleFocus, {\n        capture: true,\n        passive: true\n      });\n      return function () {\n        return target.removeEventListener('focus', handleFocus);\n      };\n    }\n  }, [target]);\n  return /*#__PURE__*/_react.default.createElement(_InternalContext.default.Provider, {\n    value: internalContext\n  }, /*#__PURE__*/_react.default.createElement(_FunctionContext.default.Provider, {\n    value: functionContext\n  }, /*#__PURE__*/_react.default.createElement(_StateContext.default.Provider, {\n    value: stateContext\n  }, children, target && /*#__PURE__*/_react.default.createElement(_EventSpy.default, {\n    debounce: debounce,\n    name: \"scroll\",\n    onEvent: handleScroll,\n    target: target\n  }), target && scrollTop !== null && /*#__PURE__*/_react.default.createElement(_SpineTo.default, {\n    name: \"scrollTop\",\n    onEnd: handleScrollEnd,\n    target: target,\n    value: scrollTop\n  }))));\n};\n\nComposer.defaultProps = {\n  checkInterval: 100,\n  children: undefined,\n  debounce: 17,\n  mode: undefined,\n  nonce: undefined\n};\nComposer.propTypes = {\n  checkInterval: _propTypes.default.number,\n  children: _propTypes.default.any,\n  debounce: _propTypes.default.number,\n  mode: _propTypes.default.oneOf(['bottom', 'top']),\n  nonce: _propTypes.default.string\n};\nvar _default = Composer;\nexports.default = _default;","map":{"version":3,"sources":["../../src/ScrollToBottom/Composer.js"],"names":["MIN_CHECK_INTERVAL","MODE_BOTTOM","MODE_TOP","NEAR_END_THRESHOLD","SCROLL_DECISION_DURATION","emotionPool","fn","setInterval","mode","target","offsetHeight","scrollHeight","scrollTop","atBottom","atTop","atEnd","atStart","Composer","checkInterval","children","debounce","nonce","ignoreScrollEventBeforeRef","setScrollTop","setTarget","setOffsetHeight","setScrollHeight","animating","setAnimating","setAtBottom","setAtEnd","setAtTop","setAtStart","sticky","setSticky","scrollPositionObserversRef","observeScrollPosition","scrollPositionObservers","index","handleScrollEnd","Date","scrollTo","behavior","console","scrollToBottom","scrollToTop","scrollToEnd","options","scrollToStart","stickyButNotAtEndSince","timeout","setImmediateInterval","Math","clearInterval","handleScroll","timeStampLow","computeViewState","nextOffsetHeight","nextScrollHeight","offsetHeightChanged","scrollHeightChanged","isEnd","actualScrollTop","observer","styleToClassName","emotion","key","internalContext","animatingToEnd","stateContext","functionContext","handleFocus","capture","passive","undefined","PropTypes","string"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,cAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,IAAA,UAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,IAAA,MAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,IAAA,aAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AACA,IAAA,SAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,IAAA,aAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,kBAAkB,GAAxB,EAAA,C,CAA+B;;AAC/B,IAAMC,WAAW,GAAjB,QAAA;AACA,IAAMC,QAAQ,GAAd,KAAA;AACA,IAAMC,kBAAkB,GAAxB,CAAA;AACA,IAAMC,wBAAwB,GAA9B,EAAA,C,CAAqC;AAErC;AACA;;AACA,IAAMC,WAAW,GAAjB,EAAA;;AAEA,SAAA,oBAAA,CAAA,EAAA,EAAA,EAAA,EAAsC;AACpCC,EAAAA,EAAE;AAEF,SAAOC,WAAW,CAAA,EAAA,EAAlB,EAAkB,CAAlB;AACD;;AAED,SAAA,gBAAA,CAAA,IAAA,EAAuF;AAAA,MAA3DC,IAA2D,GAAA,IAAA,CAA3DA,IAA2D;AAAA,MAAA,WAAA,GAAA,IAAA,CAArDC,MAAqD;AAAA,MAA3CC,YAA2C,GAAA,WAAA,CAA3CA,YAA2C;AAAA,MAA7BC,YAA6B,GAAA,WAAA,CAA7BA,YAA6B;AAAA,MAAfC,SAAe,GAAA,WAAA,CAAfA,SAAe;AACrF,MAAMC,QAAQ,GAAGF,YAAY,GAAZA,SAAAA,GAAAA,YAAAA,GAAjB,kBAAA;AACA,MAAMG,KAAK,GAAGF,SAAS,GAAvB,kBAAA;AAEA,MAAMG,KAAK,GAAGP,IAAI,KAAJA,QAAAA,GAAAA,KAAAA,GAAd,QAAA;AACA,MAAMQ,OAAO,GAAGR,IAAI,KAAJA,QAAAA,GAAAA,KAAAA,GAAhB,QAAA;AAEA,SAAO;AACLK,IAAAA,QAAQ,EADH,QAAA;AAELE,IAAAA,KAAK,EAFA,KAAA;AAGLC,IAAAA,OAAO,EAHF,OAAA;AAILF,IAAAA,KAAK,EAALA;AAJK,GAAP;AAMD;;AAED,SAAA,KAAA,CAAA,SAAA,EAAA,IAAA,EAAgC;AAC9B,SAAQN,IAAI,KAAJA,QAAAA,IAAqBI,SAAS,KAA/B,CAACJ,IAA0CA,IAAI,KAAJA,WAAAA,IAAwBI,SAAS,KAAnF,MAAA;AACD;;AAED,IAAMK,QAAQ,GAAG,SAAXA,QAAW,CAAA,KAAA,EAAwD;AAAA,MAArDC,aAAqD,GAAA,KAAA,CAArDA,aAAqD;AAAA,MAAtCC,QAAsC,GAAA,KAAA,CAAtCA,QAAsC;AAAA,MAA5BC,QAA4B,GAAA,KAAA,CAA5BA,QAA4B;AAAA,MAAlBZ,IAAkB,GAAA,KAAA,CAAlBA,IAAkB;AAAA,MAAZa,KAAY,GAAA,KAAA,CAAZA,KAAY;AACvEb,EAAAA,IAAI,GAAGA,IAAI,KAAJA,QAAAA,GAAAA,QAAAA,GAAPA,WAAAA;AAEA,MAAMc,0BAA0B,GAAG,CAAA,GAAA,MAAA,CAAA,MAAA,EAAnC,CAAmC,CAAnC;;AAHuE,MAAA,SAAA,GAIrC,CAAA,GAAA,MAAA,CAAA,QAAA,EAASd,IAAI,KAAJA,QAAAA,GAAAA,CAAAA,GAJ4B,MAIrC,CAJqC;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAA,MAIhEI,SAJgE,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAIrDW,YAJqD,GAAA,UAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,UAAA,GAK3C,CAAA,GAAA,MAAA,CAAA,QAAA,EAL2C,IAK3C,CAL2C;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAA,MAKhEd,MALgE,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAKxDe,SALwD,GAAA,UAAA,CAAA,CAAA,CAAA,CAAA,CAOvE;;;AAPuE,MAAA,UAAA,GAQ/B,CAAA,GAAA,MAAA,CAAA,QAAA,EAR+B,CAQ/B,CAR+B;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAA,MAQhEd,YARgE,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAQlDe,eARkD,GAAA,UAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,UAAA,GAS/B,CAAA,GAAA,MAAA,CAAA,QAAA,EAT+B,CAS/B,CAT+B;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAA,MAShEd,YATgE,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MASlDe,eATkD,GAAA,UAAA,CAAA,CAAA,CAAA,CAAA,CAWvE;;;AAXuE,MAAA,UAAA,GAYrC,CAAA,GAAA,MAAA,CAAA,QAAA,EAZqC,KAYrC,CAZqC;AAAA,MAAA,WAAA,GAAA,cAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAA,MAYhEC,SAZgE,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,MAYrDC,YAZqD,GAAA,WAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,WAAA,GAavC,CAAA,GAAA,MAAA,CAAA,QAAA,EAbuC,IAavC,CAbuC;AAAA,MAAA,WAAA,GAAA,cAAA,CAAA,WAAA,EAAA,CAAA,CAAA;AAAA,MAahEf,QAbgE,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,MAatDgB,WAbsD,GAAA,WAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,WAAA,GAc7C,CAAA,GAAA,MAAA,CAAA,QAAA,EAd6C,IAc7C,CAd6C;AAAA,MAAA,WAAA,GAAA,cAAA,CAAA,WAAA,EAAA,CAAA,CAAA;AAAA,MAchEd,KAdgE,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,MAczDe,QAdyD,GAAA,WAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,WAAA,GAe7C,CAAA,GAAA,MAAA,CAAA,QAAA,EAf6C,IAe7C,CAf6C;AAAA,MAAA,WAAA,GAAA,cAAA,CAAA,WAAA,EAAA,CAAA,CAAA;AAAA,MAehEhB,KAfgE,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,MAezDiB,QAfyD,GAAA,WAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,WAAA,GAgBzC,CAAA,GAAA,MAAA,CAAA,QAAA,EAhByC,KAgBzC,CAhByC;AAAA,MAAA,WAAA,GAAA,cAAA,CAAA,WAAA,EAAA,CAAA,CAAA;AAAA,MAgBhEf,OAhBgE,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,MAgBvDgB,UAhBuD,GAAA,WAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,WAAA,GAiB3C,CAAA,GAAA,MAAA,CAAA,QAAA,EAjB2C,IAiB3C,CAjB2C;AAAA,MAAA,WAAA,GAAA,cAAA,CAAA,WAAA,EAAA,CAAA,CAAA;AAAA,MAiBhEC,MAjBgE,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,MAiBxDC,SAjBwD,GAAA,WAAA,CAAA,CAAA,CAAA,CAAA,CAmBvE;;;AACA,MAAMC,0BAA0B,GAAG,CAAA,GAAA,MAAA,CAAA,MAAA,EAAnC,EAAmC,CAAnC;AACA,MAAMC,qBAAqB,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EAC5B,UAAA,EAAA,EAAM;AACJD,IAAAA,0BAA0B,CAA1BA,OAAAA,CAAAA,IAAAA,CAAAA,EAAAA;AACA1B,IAAAA,MAAM,IAAIH,EAAE,CAAC;AAAEM,MAAAA,SAAS,EAAEH,MAAM,CAACG;AAApB,KAAD,CAAZH;AAEA,WAAO,YAAM;AAAA,UACM4B,uBADN,GACkCF,0BADlC,CAAA,OAAA;AAEX,UAAMG,KAAK,GAAGD,uBAAuB,CAAvBA,OAAAA,CAAd,EAAcA,CAAd;AAEA,OAAA,KAAA,IAAUA,uBAAuB,CAAvBA,MAAAA,CAAAA,KAAAA,EAAV,CAAUA,CAAV;AAJF,KAAA;AAL0B,GAAA,EAY5B,CAAA,0BAAA,EAZF,MAYE,CAZ4B,CAA9B;AAeA,MAAME,eAAe,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EAAY,YAAM;AACxCjB,IAAAA,0BAA0B,CAA1BA,OAAAA,GAAqCkB,IAAI,CAAzClB,GAAqCkB,EAArClB;AACAM,IAAAA,YAAY,CAAZA,KAAY,CAAZA;AACAL,IAAAA,YAAY,CAAZA,IAAY,CAAZA;AAHsB,GAAA,EAIrB,CAAA,0BAAA,EAAA,YAAA,EAxCoE,YAwCpE,CAJqB,CAAxB,CApCuE,CA0CvE;;AACA,MAAMkB,QAAQ,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EACf,UAAA,SAAA,EAAkC;AAAA,QAAA,KAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,EAAO;AAAA,QAApBC,QAAoB,GAAA,KAAA,CAApBA,QAAoB;;AAChC,QAAIA,QAAQ,KAAZ,MAAA,EAAyB;AACvB;AACAH,MAAAA,eAFuB,GAAA,CAIvB;;AACA9B,MAAAA,MAAM,CAANA,SAAAA,GAAmBG,SAAS,KAATA,MAAAA,GAAuBH,MAAM,CAANA,YAAAA,GAAsBA,MAAM,CAAnDG,YAAAA,GAAnBH,SAAAA;AALF,KAAA,MAMO;AACLiC,MAAAA,QAAQ,KAARA,QAAAA,IACEC,OAAO,CAAPA,IAAAA,CADFD,0MACEC,CADFD;AAKAd,MAAAA,YAAY,CAAZA,IAAY,CAAZA;AACAL,MAAAA,YAAY,CAAZA,SAAY,CAAZA;AACD;AAhBY,GAAA,EAkBf,CAAA,eAAA,EAAA,YAAA,EAAA,YAAA,EAlBF,MAkBE,CAlBe,CAAjB;AAqBA,MAAMqB,cAAc,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EACrB,YAAuB;AAAA,QAAA,KAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,EAAO;AAAA,QAApBF,QAAoB,GAAA,KAAA,CAApBA,QAAoB;;AACrBA,IAAAA,QAAQ,KAARA,QAAAA,IACEC,OAAO,CAAPA,IAAAA,CADFD,gNACEC,CADFD;AAKAD,IAAAA,QAAQ,CAAA,MAAA,EAAS;AAAEC,MAAAA,QAAQ,EAAEA,QAAQ,IAAI;AAAxB,KAAT,CAARD;AAPmB,GAAA,EASrB,CATF,QASE,CATqB,CAAvB;AAYA,MAAMI,WAAW,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EAClB,YAAuB;AAAA,QAAA,KAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,EAAO;AAAA,QAApBH,QAAoB,GAAA,KAAA,CAApBA,QAAoB;;AACrBA,IAAAA,QAAQ,KAARA,QAAAA,IACEC,OAAO,CAAPA,IAAAA,CADFD,6MACEC,CADFD;AAKAD,IAAAA,QAAQ,CAAA,CAAA,EAAI;AAAEC,MAAAA,QAAQ,EAAEA,QAAQ,IAAI;AAAxB,KAAJ,CAARD;AAPgB,GAAA,EASlB,CATF,QASE,CATkB,CAApB;AAYA,MAAMK,WAAW,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EAClB,YAAuB;AAAA,QAAA,KAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,EAAO;AAAA,QAApBJ,QAAoB,GAAA,KAAA,CAApBA,QAAoB;;AACrBA,IAAAA,QAAQ,KAARA,QAAAA,IACEC,OAAO,CAAPA,IAAAA,CADFD,6MACEC,CADFD;AAKA,QAAMK,OAAO,GAAG;AAAEL,MAAAA,QAAQ,EAAEA,QAAQ,IAAI;AAAxB,KAAhB;AAEAlC,IAAAA,IAAI,KAAJA,QAAAA,GAAoBqC,WAAW,CAA/BrC,OAA+B,CAA/BA,GAA2CoC,cAAc,CAAzDpC,OAAyD,CAAzDA;AATgB,GAAA,EAWlB,CAAA,IAAA,EAAA,cAAA,EAXF,WAWE,CAXkB,CAApB;AAcA,MAAMwC,aAAa,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EACpB,YAAuB;AAAA,QAAA,KAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,EAAO;AAAA,QAApBN,QAAoB,GAAA,KAAA,CAApBA,QAAoB;;AACrBA,IAAAA,QAAQ,KAARA,QAAAA,IACEC,OAAO,CAAPA,IAAAA,CADFD,+MACEC,CADFD;AAKA,QAAMK,OAAO,GAAG;AAAEL,MAAAA,QAAQ,EAAEA,QAAQ,IAAI;AAAxB,KAAhB;AAEAlC,IAAAA,IAAI,KAAJA,QAAAA,GAAoBoC,cAAc,CAAlCpC,OAAkC,CAAlCA,GAA8CqC,WAAW,CAAzDrC,OAAyD,CAAzDA;AATkB,GAAA,EAWpB,CAAA,IAAA,EAAA,cAAA,EAXF,WAWE,CAXoB,CAAtB;AAcA,GAAA,GAAA,MAAA,CAAA,SAAA,EAAU,YAAM;AACd,QAAA,MAAA,EAAY;AACV,UAAIyC,sBAAsB,GAA1B,KAAA;AAEA,UAAMC,OAAO,GAAGC,oBAAoB,CAAC,YAAM;AACzC,YAAIlB,MAAM,IAANA,MAAAA,IAAoB,CAAC,gBAAgB,CAAC;AAAEzB,UAAAA,IAAI,EAAN,IAAA;AAAQC,UAAAA,MAAM,EAANA;AAAR,SAAD,CAAhB,CAAzB,KAAA,EAAmE;AACjE,cAAI,CAAJ,sBAAA,EAA6B;AAC3BwC,YAAAA,sBAAsB,GAAGT,IAAI,CAA7BS,GAAyBT,EAAzBS;AADF,WAAA,MAEO,IAAIT,IAAI,CAAJA,GAAAA,KAAAA,sBAAAA,GAAJ,wBAAA,EAAoE;AACzE;AACA;AACA;AACA;AACA;AACA;AAEA,aAAA,SAAA,IAAcM,WAAW,CAAC;AAAEJ,cAAAA,QAAQ,EAAE;AAAZ,aAAD,CAAzB;AACAO,YAAAA,sBAAsB,GAAtBA,KAAAA;AACD;AAbH,SAAA,MAcO;AACLA,UAAAA,sBAAsB,GAAtBA,KAAAA;AACD;AAjBiC,OAAA,EAkBjCG,IAAI,CAAJA,GAAAA,CAAAA,kBAAAA,EAAAA,aAAAA,KAlBH,kBAAoC,CAApC;AAoBA,aAAO,YAAA;AAAA,eAAMC,aAAa,CAAnB,OAAmB,CAAnB;AAAP,OAAA;AACD;AAzBH,GAAA,EA0BG,CAAA,SAAA,EAAA,aAAA,EAAA,IAAA,EAAA,WAAA,EAAA,MAAA,EA1BH,MA0BG,CA1BH;AA4BA,MAAMC,YAAY,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EACnB,UAAA,KAAA,EAAsB;AAAA,QAAnBC,YAAmB,GAAA,KAAA,CAAnBA,YAAmB,CAAA,CACpB;AACA;AACA;;AAEA,QAAIA,YAAY,IAAIjC,0BAA0B,CAA9C,OAAA,EAAwD;AACtD;AACA;AACA;AAEA;AACD;;AAED,QAAA,MAAA,EAAY;AAAA,UAAA,iBAAA,GACkCkC,gBAAgB,CAAC;AAAEhD,QAAAA,IAAI,EAAN,IAAA;AAAQC,QAAAA,MAAM,EAANA;AAAR,OAAD,CADlD;AAAA,UACFI,SADE,GAAA,iBAAA,CAAA,QAAA;AAAA,UACQE,MADR,GAAA,iBAAA,CAAA,KAAA;AAAA,UACeC,QADf,GAAA,iBAAA,CAAA,OAAA;AAAA,UACwBF,MADxB,GAAA,iBAAA,CAAA,KAAA;;AAGVe,MAAAA,WAAW,CAAXA,SAAW,CAAXA;AACAC,MAAAA,QAAQ,CAARA,MAAQ,CAARA;AACAE,MAAAA,UAAU,CAAVA,QAAU,CAAVA;AACAD,MAAAA,QAAQ,CANE,MAMF,CAARA,CANU,CAQV;AACA;AACA;AACA;;AAXU,UAYY0B,gBAZZ,GAYiEhD,MAZjE,CAAA,YAAA;AAAA,UAY4CiD,gBAZ5C,GAYiEjD,MAZjE,CAAA,YAAA;AAaV,UAAMkD,mBAAmB,GAAGF,gBAAgB,KAA5C,YAAA;AACA,UAAMG,mBAAmB,GAAGF,gBAAgB,KAA5C,YAAA;AAEAC,MAAAA,mBAAmB,IAAIlC,eAAe,CAAtCkC,gBAAsC,CAAtCA;AACAC,MAAAA,mBAAmB,IAAIlC,eAAe,CAjB5B,gBAiB4B,CAAtCkC,CAjBU,CAmBV;AACA;AACA;AAEA;;AACA,OAAA,mBAAA,IACE,CADF,mBAAA,IAEE1B,SAAS,EACP;AACA;AACCP,MAAAA,SAAS,IAAIkC,KAAK,CAAA,SAAA,EAAnB,IAAmB,CAAlBlC,IA7BK,MA0BC,CAFX,CAxBU,CAgCV;AACA;;AACAf,MAAAA,SAAS,KAATA,IAAAA,IAAsBgB,YAAY,CAAlChB,KAAkC,CAAlCA;AAlCU,UAoCSkD,eApCT,GAoC6BrD,MApC7B,CAAA,SAAA;AAsCV0B,MAAAA,0BAA0B,CAA1BA,OAAAA,CAAAA,OAAAA,CAA2C,UAAA,QAAA,EAAQ;AAAA,eAAI4B,QAAQ,CAAC;AAAEnD,UAAAA,SAAS,EAAEkD;AAAb,SAAD,CAAZ;AAAnD3B,OAAAA;AACD;AArDgB,GAAA,EAuDnB,CAAA,SAAA,EAAA,0BAAA,EAAA,IAAA,EAAA,YAAA,EAAA,YAAA,EAAA,0BAAA,EAAA,SAAA,EAAA,YAAA,EAAA,WAAA,EAAA,QAAA,EAAA,UAAA,EAAA,QAAA,EAAA,eAAA,EAAA,eAAA,EAAA,SAAA,EAvDF,MAuDE,CAvDmB,CAArB;AA2EA,MAAM6B,gBAAgB,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EAAQ,YAAM;AACrC,QAAMC,OAAO,GACX,WAAW,CAAX,KAAW,CAAX,KAAuB5D,WAAW,CAAXA,KAAW,CAAXA,GAAqB,CAAA,GAAA,cAAA,CAAA,OAAA,EAAc;AAAE6D,MAAAA,GAAG,EAAA,+BAAA,MAAA,CAAiC,CAAA,GAAA,aAAA,CAAtC,OAAsC,GAAjC,CAAL;AAAwD7C,MAAAA,KAAK,EAALA;AAAxD,KAAd,CAA5C,CADF;AAGA,WAAO,UAAA,KAAA,EAAK;AAAA,aAAI4C,OAAO,CAAPA,GAAAA,CAAAA,KAAAA,IAAJ,EAAA;AAAZ,KAAA;AAJuB,GAAA,EAKtB,CALH,KAKG,CALsB,CAAzB;AAOA,MAAME,eAAe,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EACtB,YAAA;AAAA,WAAO;AACL/B,MAAAA,qBAAqB,EADhB,qBAAA;AAEL1B,MAAAA,YAAY,EAFP,YAAA;AAGLC,MAAAA,YAAY,EAHP,YAAA;AAILa,MAAAA,SAAS,EAJJ,SAAA;AAKLwC,MAAAA,gBAAgB,EAAhBA;AALK,KAAP;AADsB,GAAA,EAQtB,CAAA,qBAAA,EAAA,YAAA,EAAA,YAAA,EAAA,SAAA,EARF,gBAQE,CARsB,CAAxB;AAWA,MAAMI,cAAc,GAAGzC,SAAS,IAAIkC,KAAK,CAAA,SAAA,EAAzC,IAAyC,CAAzC;AAEA,MAAMQ,YAAY,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EACnB,YAAA;AAAA,WAAO;AACL1C,MAAAA,SAAS,EADJ,SAAA;AAELyC,MAAAA,cAAc,EAFT,cAAA;AAGLvD,MAAAA,QAAQ,EAHH,QAAA;AAILE,MAAAA,KAAK,EAJA,KAAA;AAKLC,MAAAA,OAAO,EALF,OAAA;AAMLF,MAAAA,KAAK,EANA,KAAA;AAOLN,MAAAA,IAAI,EAPC,IAAA;AAQLyB,MAAAA,MAAM,EAANA;AARK,KAAP;AADmB,GAAA,EAWnB,CAAA,SAAA,EAAA,cAAA,EAAA,QAAA,EAAA,KAAA,EAAA,OAAA,EAAA,KAAA,EAAA,IAAA,EAXF,MAWE,CAXmB,CAArB;AAcA,MAAMqC,eAAe,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EACtB,YAAA;AAAA,WAAO;AACL7B,MAAAA,QAAQ,EADH,QAAA;AAELG,MAAAA,cAAc,EAFT,cAAA;AAGLE,MAAAA,WAAW,EAHN,WAAA;AAILE,MAAAA,aAAa,EAJR,aAAA;AAKLH,MAAAA,WAAW,EAAXA;AALK,KAAP;AADsB,GAAA,EAQtB,CAAA,QAAA,EAAA,cAAA,EAAA,WAAA,EAAA,aAAA,EARF,WAQE,CARsB,CAAxB;AAWA,GAAA,GAAA,MAAA,CAAA,SAAA,EAAU,YAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,MAAA,EAAY;AACV,UAAM0B,WAAW,GAAG,SAAdA,WAAc,GAAA;AAAA,eAAM7C,eAAe,CAACjB,MAAM,CAA5B,YAAqB,CAArB;AAApB,OAAA;;AAEAA,MAAAA,MAAM,CAANA,gBAAAA,CAAAA,OAAAA,EAAAA,WAAAA,EAA8C;AAAE+D,QAAAA,OAAO,EAAT,IAAA;AAAiBC,QAAAA,OAAO,EAAE;AAA1B,OAA9ChE;AAEA,aAAO,YAAA;AAAA,eAAMA,MAAM,CAANA,mBAAAA,CAAAA,OAAAA,EAAN,WAAMA,CAAN;AAAP,OAAA;AACD;AA1BH,GAAA,EA2BG,CA3BH,MA2BG,CA3BH;AA6BA,SAAA,aACE,MAAA,CAAA,OAAA,CAAA,aAAA,CAAC,gBAAA,CAAD,OAAC,CAAD,QAAA,EAAA;AAA0B,IAAA,KAAK,EAAE0D;AAAjC,GAAA,EAAA,aACE,MAAA,CAAA,OAAA,CAAA,aAAA,CAAC,gBAAA,CAAD,OAAC,CAAD,QAAA,EAAA;AAA0B,IAAA,KAAK,EAAEG;AAAjC,GAAA,EAAA,aACE,MAAA,CAAA,OAAA,CAAA,aAAA,CAAC,aAAA,CAAD,OAAC,CAAD,QAAA,EAAA;AAAuB,IAAA,KAAK,EAAED;AAA9B,GAAA,EAAA,QAAA,EAEG5D,MAAM,IAAA,aAAI,MAAA,CAAA,OAAA,CAAA,aAAA,CAAC,SAAA,CAAD,OAAA,EAAA;AAAU,IAAA,QAAQ,EAAlB,QAAA;AAA8B,IAAA,IAAI,EAAlC,QAAA;AAA4C,IAAA,OAAO,EAAnD,YAAA;AAAmE,IAAA,MAAM,EAAEA;AAA3E,GAAA,CAFb,EAGGA,MAAM,IAAIG,SAAS,KAAnBH,IAAAA,IAAAA,aACC,MAAA,CAAA,OAAA,CAAA,aAAA,CAAC,QAAA,CAAD,OAAA,EAAA;AAAS,IAAA,IAAI,EAAb,WAAA;AAA0B,IAAA,KAAK,EAA/B,eAAA;AAAkD,IAAA,MAAM,EAAxD,MAAA;AAAkE,IAAA,KAAK,EAAEG;AAAzE,GAAA,CAJJ,CADF,CADF,CADF;AArSF,CAAA;;AAoTAK,QAAQ,CAARA,YAAAA,GAAwB;AACtBC,EAAAA,aAAa,EADS,GAAA;AAEtBC,EAAAA,QAAQ,EAFc,SAAA;AAGtBC,EAAAA,QAAQ,EAHc,EAAA;AAItBZ,EAAAA,IAAI,EAJkB,SAAA;AAKtBa,EAAAA,KAAK,EAAEqD;AALe,CAAxBzD;AAQAA,QAAQ,CAARA,SAAAA,GAAqB;AACnBC,EAAAA,aAAa,EAAEyD,UAAAA,CAAAA,OAAAA,CADI,MAAA;AAEnBxD,EAAAA,QAAQ,EAAEwD,UAAAA,CAAAA,OAAAA,CAFS,GAAA;AAGnBvD,EAAAA,QAAQ,EAAEuD,UAAAA,CAAAA,OAAAA,CAHS,MAAA;AAInBnE,EAAAA,IAAI,EAAEmE,UAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAgB,CAAA,QAAA,EAJH,KAIG,CAAhBA,CAJa;AAKnBtD,EAAAA,KAAK,EAAEsD,UAAAA,CAAAA,OAAAA,CAAUC;AALE,CAArB3D;eAQeA,Q","sourcesContent":["import createEmotion from 'create-emotion';\nimport PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport createCSSKey from '../createCSSKey';\nimport EventSpy from '../EventSpy';\nimport FunctionContext from './FunctionContext';\nimport InternalContext from './InternalContext';\nimport SpineTo from '../SpineTo';\nimport StateContext from './StateContext';\n\nconst MIN_CHECK_INTERVAL = 17; // 1 frame\nconst MODE_BOTTOM = 'bottom';\nconst MODE_TOP = 'top';\nconst NEAR_END_THRESHOLD = 1;\nconst SCROLL_DECISION_DURATION = 34; // 2 frames\n\n// We pool the emotion object by nonce.\n// This is to make sure we don't generate too many unneeded <style> tags.\nconst emotionPool = {};\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState({ mode, target: { offsetHeight, scrollHeight, scrollTop } }) {\n  const atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  const atTop = scrollTop < NEAR_END_THRESHOLD;\n\n  const atEnd = mode === MODE_TOP ? atTop : atBottom;\n  const atStart = mode !== MODE_TOP ? atTop : atBottom;\n\n  return {\n    atBottom,\n    atEnd,\n    atStart,\n    atTop\n  };\n}\n\nfunction isEnd(scrollTop, mode) {\n  return (mode === MODE_TOP && scrollTop === 0) || (mode === MODE_BOTTOM && scrollTop === '100%');\n}\n\nconst Composer = ({ checkInterval, children, debounce, mode, nonce }) => {\n  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;\n\n  const ignoreScrollEventBeforeRef = useRef(0);\n  const [scrollTop, setScrollTop] = useState(mode === MODE_TOP ? 0 : '100%');\n  const [target, setTarget] = useState(null);\n\n  // Internal context\n  const [offsetHeight, setOffsetHeight] = useState(0);\n  const [scrollHeight, setScrollHeight] = useState(0);\n\n  // State context\n  const [animating, setAnimating] = useState(false);\n  const [atBottom, setAtBottom] = useState(true);\n  const [atEnd, setAtEnd] = useState(true);\n  const [atTop, setAtTop] = useState(true);\n  const [atStart, setAtStart] = useState(false);\n  const [sticky, setSticky] = useState(true);\n\n  // High-rate state context\n  const scrollPositionObserversRef = useRef([]);\n  const observeScrollPosition = useCallback(\n    fn => {\n      scrollPositionObserversRef.current.push(fn);\n      target && fn({ scrollTop: target.scrollTop });\n\n      return () => {\n        const { current: scrollPositionObservers } = scrollPositionObserversRef;\n        const index = scrollPositionObservers.indexOf(fn);\n\n        ~index && scrollPositionObservers.splice(index, 1);\n      };\n    },\n    [scrollPositionObserversRef, target]\n  );\n\n  const handleScrollEnd = useCallback(() => {\n    ignoreScrollEventBeforeRef.current = Date.now();\n    setAnimating(false);\n    setScrollTop(null);\n  }, [ignoreScrollEventBeforeRef, setAnimating, setScrollTop]);\n\n  // Function context\n  const scrollTo = useCallback(\n    (scrollTop, { behavior } = {}) => {\n      if (behavior === 'auto') {\n        // Stop any existing animation\n        handleScrollEnd();\n\n        // Jump to the scroll position\n        target.scrollTop = scrollTop === '100%' ? target.scrollHeight - target.offsetHeight : scrollTop;\n      } else {\n        behavior !== 'smooth' &&\n          console.warn(\n            'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollTo\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n          );\n\n        setAnimating(true);\n        setScrollTop(scrollTop);\n      }\n    },\n    [handleScrollEnd, setAnimating, setScrollTop, target]\n  );\n\n  const scrollToBottom = useCallback(\n    ({ behavior } = {}) => {\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToBottom\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      scrollTo('100%', { behavior: behavior || 'smooth' });\n    },\n    [scrollTo]\n  );\n\n  const scrollToTop = useCallback(\n    ({ behavior } = {}) => {\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToTop\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      scrollTo(0, { behavior: behavior || 'smooth' });\n    },\n    [scrollTo]\n  );\n\n  const scrollToEnd = useCallback(\n    ({ behavior } = {}) => {\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToEnd\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      const options = { behavior: behavior || 'smooth' };\n\n      mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);\n    },\n    [mode, scrollToBottom, scrollToTop]\n  );\n\n  const scrollToStart = useCallback(\n    ({ behavior } = {}) => {\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToStart\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      const options = { behavior: behavior || 'smooth' };\n\n      mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);\n    },\n    [mode, scrollToBottom, scrollToTop]\n  );\n\n  useEffect(() => {\n    if (sticky) {\n      let stickyButNotAtEndSince = false;\n\n      const timeout = setImmediateInterval(() => {\n        if (sticky && target && !computeViewState({ mode, target }).atEnd) {\n          if (!stickyButNotAtEndSince) {\n            stickyButNotAtEndSince = Date.now();\n          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n            // Quirks: In Firefox, after user scroll down, Firefox do two things:\n            //         1. Set to a new \"scrollTop\"\n            //         2. Fire \"scroll\" event\n            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n\n            !animating && scrollToEnd({ behavior: 'smooth' });\n            stickyButNotAtEndSince = false;\n          }\n        } else {\n          stickyButNotAtEndSince = false;\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);\n\n      return () => clearInterval(timeout);\n    }\n  }, [animating, checkInterval, mode, scrollToEnd, sticky, target]);\n\n  const handleScroll = useCallback(\n    ({ timeStampLow }) => {\n      // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n      // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n      if (timeStampLow <= ignoreScrollEventBeforeRef.current) {\n        // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n        // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n\n        return;\n      }\n\n      if (target) {\n        const { atBottom, atEnd, atStart, atTop } = computeViewState({ mode, target });\n\n        setAtBottom(atBottom);\n        setAtEnd(atEnd);\n        setAtStart(atStart);\n        setAtTop(atTop);\n\n        // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n        // We need to ignore these \"synthetic\" events\n        // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n        //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom\n        const { offsetHeight: nextOffsetHeight, scrollHeight: nextScrollHeight } = target;\n        const offsetHeightChanged = nextOffsetHeight !== offsetHeight;\n        const scrollHeightChanged = nextScrollHeight !== scrollHeight;\n\n        offsetHeightChanged && setOffsetHeight(nextOffsetHeight);\n        scrollHeightChanged && setScrollHeight(nextScrollHeight);\n\n        // Sticky means:\n        // - If it is scrolled programatically, we are still in sticky mode\n        // - If it is scrolled by the user, then sticky means if we are at the end\n\n        // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n        !offsetHeightChanged &&\n          !scrollHeightChanged &&\n          setSticky(\n            // We are sticky if we are animating to the end, or we are already at the end.\n            // We can be \"animating but not sticky\" by calling \"scrollTo(100)\" where the container scrollHeight is 200px.\n            (animating && isEnd(scrollTop, mode)) || atEnd\n          );\n\n        // If no scrollTop is set (not in programmatic scrolling mode), we should set \"animating\" to false\n        // \"animating\" is used to calculate the \"sticky\" property\n        scrollTop === null && setAnimating(false);\n\n        const { scrollTop: actualScrollTop } = target;\n\n        scrollPositionObserversRef.current.forEach(observer => observer({ scrollTop: actualScrollTop }));\n      }\n    },\n    [\n      animating,\n      ignoreScrollEventBeforeRef,\n      mode,\n      offsetHeight,\n      scrollHeight,\n      scrollPositionObserversRef,\n      scrollTop,\n      setAnimating,\n      setAtBottom,\n      setAtEnd,\n      setAtStart,\n      setAtTop,\n      setOffsetHeight,\n      setScrollHeight,\n      setSticky,\n      target\n    ]\n  );\n\n  const styleToClassName = useMemo(() => {\n    const emotion =\n      emotionPool[nonce] || (emotionPool[nonce] = createEmotion({ key: `react-scroll-to-bottom--css-${createCSSKey()}`, nonce }));\n\n    return style => emotion.css(style) + '';\n  }, [nonce]);\n\n  const internalContext = useMemo(\n    () => ({\n      observeScrollPosition,\n      offsetHeight,\n      scrollHeight,\n      setTarget,\n      styleToClassName\n    }),\n    [observeScrollPosition, offsetHeight, scrollHeight, setTarget, styleToClassName]\n  );\n\n  const animatingToEnd = animating && isEnd(scrollTop, mode);\n\n  const stateContext = useMemo(\n    () => ({\n      animating,\n      animatingToEnd,\n      atBottom,\n      atEnd,\n      atStart,\n      atTop,\n      mode,\n      sticky\n    }),\n    [animating, animatingToEnd, atBottom, atEnd, atStart, atTop, mode, sticky]\n  );\n\n  const functionContext = useMemo(\n    () => ({\n      scrollTo,\n      scrollToBottom,\n      scrollToEnd,\n      scrollToStart,\n      scrollToTop\n    }),\n    [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]\n  );\n\n  useEffect(() => {\n    // We need to update the \"scrollHeight\" value to latest when the user do a focus inside the box.\n    //\n    // This is because:\n    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether \"scrollHeight\" value is latest or not.\n    // - That code only run on \"scroll\" event.\n    // - That means, on every \"scroll\" event, if the \"scrollHeight\" value is not latest, we will skip modifying the stickiness.\n    // - That means, if the user \"focus\" to an element that cause the scroll view to scroll to the bottom, the user agent will fire \"scroll\" event.\n    //   Since the \"scrollHeight\" is not latest value, this \"scroll\" event will be ignored and stickiness will not be modified.\n    // - That means, if the user \"focus\" to a newly added element that is at the end of the scroll view, the \"scroll to bottom\" button will continue to show.\n    //\n    // Repro in Chrome:\n    // 1. Fill up a scroll view\n    // 2. Scroll up, the \"scroll to bottom\" button should show up\n    // 3. Click \"Add a button\"\n    // 4. Click on the scroll view (to pseudo-focus on it)\n    // 5. Press TAB, the scroll view will be at the bottom\n    //\n    // Expect:\n    // - The \"scroll to bottom\" button should be gone.\n    if (target) {\n      const handleFocus = () => setScrollHeight(target.scrollHeight);\n\n      target.addEventListener('focus', handleFocus, { capture: true, passive: true });\n\n      return () => target.removeEventListener('focus', handleFocus);\n    }\n  }, [target]);\n\n  return (\n    <InternalContext.Provider value={internalContext}>\n      <FunctionContext.Provider value={functionContext}>\n        <StateContext.Provider value={stateContext}>\n          {children}\n          {target && <EventSpy debounce={debounce} name=\"scroll\" onEvent={handleScroll} target={target} />}\n          {target && scrollTop !== null && (\n            <SpineTo name=\"scrollTop\" onEnd={handleScrollEnd} target={target} value={scrollTop} />\n          )}\n        </StateContext.Provider>\n      </FunctionContext.Provider>\n    </InternalContext.Provider>\n  );\n};\n\nComposer.defaultProps = {\n  checkInterval: 100,\n  children: undefined,\n  debounce: 17,\n  mode: undefined,\n  nonce: undefined\n};\n\nComposer.propTypes = {\n  checkInterval: PropTypes.number,\n  children: PropTypes.any,\n  debounce: PropTypes.number,\n  mode: PropTypes.oneOf(['bottom', 'top']),\n  nonce: PropTypes.string\n};\n\nexport default Composer;\n"]},"metadata":{},"sourceType":"script"}