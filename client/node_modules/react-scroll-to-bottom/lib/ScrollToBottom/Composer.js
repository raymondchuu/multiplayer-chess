"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createEmotion = _interopRequireDefault(require("create-emotion"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _createCSSKey = _interopRequireDefault(require("../createCSSKey"));

var _EventSpy = _interopRequireDefault(require("../EventSpy"));

var _FunctionContext = _interopRequireDefault(require("./FunctionContext"));

var _InternalContext = _interopRequireDefault(require("./InternalContext"));

var _SpineTo = _interopRequireDefault(require("../SpineTo"));

var _StateContext = _interopRequireDefault(require("./StateContext"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var MIN_CHECK_INTERVAL = 17; // 1 frame

var MODE_BOTTOM = 'bottom';
var MODE_TOP = 'top';
var NEAR_END_THRESHOLD = 1;
var SCROLL_DECISION_DURATION = 34; // 2 frames
// We pool the emotion object by nonce.
// This is to make sure we don't generate too many unneeded <style> tags.

var emotionPool = {};

function setImmediateInterval(fn, ms) {
  fn();
  return setInterval(fn, ms);
}

function computeViewState(_ref) {
  var mode = _ref.mode,
      _ref$target = _ref.target,
      offsetHeight = _ref$target.offsetHeight,
      scrollHeight = _ref$target.scrollHeight,
      scrollTop = _ref$target.scrollTop;
  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;
  var atTop = scrollTop < NEAR_END_THRESHOLD;
  var atEnd = mode === MODE_TOP ? atTop : atBottom;
  var atStart = mode !== MODE_TOP ? atTop : atBottom;
  return {
    atBottom: atBottom,
    atEnd: atEnd,
    atStart: atStart,
    atTop: atTop
  };
}

function isEnd(scrollTop, mode) {
  return mode === MODE_TOP && scrollTop === 0 || mode === MODE_BOTTOM && scrollTop === '100%';
}

var Composer = function Composer(_ref2) {
  var checkInterval = _ref2.checkInterval,
      children = _ref2.children,
      debounce = _ref2.debounce,
      mode = _ref2.mode,
      nonce = _ref2.nonce;
  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;
  var ignoreScrollEventBeforeRef = (0, _react.useRef)(0);

  var _useState = (0, _react.useState)(mode === MODE_TOP ? 0 : '100%'),
      _useState2 = _slicedToArray(_useState, 2),
      scrollTop = _useState2[0],
      setScrollTop = _useState2[1];

  var _useState3 = (0, _react.useState)(null),
      _useState4 = _slicedToArray(_useState3, 2),
      target = _useState4[0],
      setTarget = _useState4[1]; // Internal context


  var _useState5 = (0, _react.useState)(0),
      _useState6 = _slicedToArray(_useState5, 2),
      offsetHeight = _useState6[0],
      setOffsetHeight = _useState6[1];

  var _useState7 = (0, _react.useState)(0),
      _useState8 = _slicedToArray(_useState7, 2),
      scrollHeight = _useState8[0],
      setScrollHeight = _useState8[1]; // State context


  var _useState9 = (0, _react.useState)(false),
      _useState10 = _slicedToArray(_useState9, 2),
      animating = _useState10[0],
      setAnimating = _useState10[1];

  var _useState11 = (0, _react.useState)(true),
      _useState12 = _slicedToArray(_useState11, 2),
      atBottom = _useState12[0],
      setAtBottom = _useState12[1];

  var _useState13 = (0, _react.useState)(true),
      _useState14 = _slicedToArray(_useState13, 2),
      atEnd = _useState14[0],
      setAtEnd = _useState14[1];

  var _useState15 = (0, _react.useState)(true),
      _useState16 = _slicedToArray(_useState15, 2),
      atTop = _useState16[0],
      setAtTop = _useState16[1];

  var _useState17 = (0, _react.useState)(false),
      _useState18 = _slicedToArray(_useState17, 2),
      atStart = _useState18[0],
      setAtStart = _useState18[1];

  var _useState19 = (0, _react.useState)(true),
      _useState20 = _slicedToArray(_useState19, 2),
      sticky = _useState20[0],
      setSticky = _useState20[1]; // High-rate state context


  var scrollPositionObserversRef = (0, _react.useRef)([]);
  var observeScrollPosition = (0, _react.useCallback)(function (fn) {
    scrollPositionObserversRef.current.push(fn);
    target && fn({
      scrollTop: target.scrollTop
    });
    return function () {
      var scrollPositionObservers = scrollPositionObserversRef.current;
      var index = scrollPositionObservers.indexOf(fn);
      ~index && scrollPositionObservers.splice(index, 1);
    };
  }, [scrollPositionObserversRef, target]);
  var handleScrollEnd = (0, _react.useCallback)(function () {
    ignoreScrollEventBeforeRef.current = Date.now();
    setAnimating(false);
    setScrollTop(null);
  }, [ignoreScrollEventBeforeRef, setAnimating, setScrollTop]); // Function context

  var scrollTo = (0, _react.useCallback)(function (scrollTop) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        behavior = _ref3.behavior;

    if (behavior === 'auto') {
      // Stop any existing animation
      handleScrollEnd(); // Jump to the scroll position

      target.scrollTop = scrollTop === '100%' ? target.scrollHeight - target.offsetHeight : scrollTop;
    } else {
      behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollTo". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
      setAnimating(true);
      setScrollTop(scrollTop);
    }
  }, [handleScrollEnd, setAnimating, setScrollTop, target]);
  var scrollToBottom = (0, _react.useCallback)(function () {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref4.behavior;

    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToBottom". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    scrollTo('100%', {
      behavior: behavior || 'smooth'
    });
  }, [scrollTo]);
  var scrollToTop = (0, _react.useCallback)(function () {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref5.behavior;

    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToTop". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    scrollTo(0, {
      behavior: behavior || 'smooth'
    });
  }, [scrollTo]);
  var scrollToEnd = (0, _react.useCallback)(function () {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref6.behavior;

    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToEnd". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var options = {
      behavior: behavior || 'smooth'
    };
    mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);
  }, [mode, scrollToBottom, scrollToTop]);
  var scrollToStart = (0, _react.useCallback)(function () {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref7.behavior;

    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToStart". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var options = {
      behavior: behavior || 'smooth'
    };
    mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);
  }, [mode, scrollToBottom, scrollToTop]);
  (0, _react.useEffect)(function () {
    if (sticky) {
      var stickyButNotAtEndSince = false;
      var timeout = setImmediateInterval(function () {
        if (sticky && target && !computeViewState({
          mode: mode,
          target: target
        }).atEnd) {
          if (!stickyButNotAtEndSince) {
            stickyButNotAtEndSince = Date.now();
          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {
            // Quirks: In Firefox, after user scroll down, Firefox do two things:
            //         1. Set to a new "scrollTop"
            //         2. Fire "scroll" event
            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.
            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.
            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.
            !animating && scrollToEnd({
              behavior: 'smooth'
            });
            stickyButNotAtEndSince = false;
          }
        } else {
          stickyButNotAtEndSince = false;
        }
      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);
      return function () {
        return clearInterval(timeout);
      };
    }
  }, [animating, checkInterval, mode, scrollToEnd, sticky, target]);
  var handleScroll = (0, _react.useCallback)(function (_ref8) {
    var timeStampLow = _ref8.timeStampLow;

    // Currently, there are no reliable way to check if the "scroll" event is trigger due to
    // user gesture, programmatic scrolling, or Chrome-synthesized "scroll" event to compensate size change.
    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.
    if (timeStampLow <= ignoreScrollEventBeforeRef.current) {
      // Since we debounce "scroll" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).
      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.
      // Thus, on a fast machine, adding elements super fast will lose the "stickiness".
      return;
    }

    if (target) {
      var _computeViewState = computeViewState({
        mode: mode,
        target: target
      }),
          _atBottom = _computeViewState.atBottom,
          _atEnd = _computeViewState.atEnd,
          _atStart = _computeViewState.atStart,
          _atTop = _computeViewState.atTop;

      setAtBottom(_atBottom);
      setAtEnd(_atEnd);
      setAtStart(_atStart);
      setAtTop(_atTop); // Chrome will emit "synthetic" scroll event if the container is resized or an element is added
      // We need to ignore these "synthetic" events
      // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)
      //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom

      var nextOffsetHeight = target.offsetHeight,
          nextScrollHeight = target.scrollHeight;
      var offsetHeightChanged = nextOffsetHeight !== offsetHeight;
      var scrollHeightChanged = nextScrollHeight !== scrollHeight;
      offsetHeightChanged && setOffsetHeight(nextOffsetHeight);
      scrollHeightChanged && setScrollHeight(nextScrollHeight); // Sticky means:
      // - If it is scrolled programatically, we are still in sticky mode
      // - If it is scrolled by the user, then sticky means if we are at the end
      // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome

      !offsetHeightChanged && !scrollHeightChanged && setSticky( // We are sticky if we are animating to the end, or we are already at the end.
      // We can be "animating but not sticky" by calling "scrollTo(100)" where the container scrollHeight is 200px.
      animating && isEnd(scrollTop, mode) || _atEnd); // If no scrollTop is set (not in programmatic scrolling mode), we should set "animating" to false
      // "animating" is used to calculate the "sticky" property

      scrollTop === null && setAnimating(false);
      var actualScrollTop = target.scrollTop;
      scrollPositionObserversRef.current.forEach(function (observer) {
        return observer({
          scrollTop: actualScrollTop
        });
      });
    }
  }, [animating, ignoreScrollEventBeforeRef, mode, offsetHeight, scrollHeight, scrollPositionObserversRef, scrollTop, setAnimating, setAtBottom, setAtEnd, setAtStart, setAtTop, setOffsetHeight, setScrollHeight, setSticky, target]);
  var styleToClassName = (0, _react.useMemo)(function () {
    var emotion = emotionPool[nonce] || (emotionPool[nonce] = (0, _createEmotion.default)({
      key: "react-scroll-to-bottom--css-".concat((0, _createCSSKey.default)()),
      nonce: nonce
    }));
    return function (style) {
      return emotion.css(style) + '';
    };
  }, [nonce]);
  var internalContext = (0, _react.useMemo)(function () {
    return {
      observeScrollPosition: observeScrollPosition,
      offsetHeight: offsetHeight,
      scrollHeight: scrollHeight,
      setTarget: setTarget,
      styleToClassName: styleToClassName
    };
  }, [observeScrollPosition, offsetHeight, scrollHeight, setTarget, styleToClassName]);
  var animatingToEnd = animating && isEnd(scrollTop, mode);
  var stateContext = (0, _react.useMemo)(function () {
    return {
      animating: animating,
      animatingToEnd: animatingToEnd,
      atBottom: atBottom,
      atEnd: atEnd,
      atStart: atStart,
      atTop: atTop,
      mode: mode,
      sticky: sticky
    };
  }, [animating, animatingToEnd, atBottom, atEnd, atStart, atTop, mode, sticky]);
  var functionContext = (0, _react.useMemo)(function () {
    return {
      scrollTo: scrollTo,
      scrollToBottom: scrollToBottom,
      scrollToEnd: scrollToEnd,
      scrollToStart: scrollToStart,
      scrollToTop: scrollToTop
    };
  }, [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]);
  (0, _react.useEffect)(function () {
    // We need to update the "scrollHeight" value to latest when the user do a focus inside the box.
    //
    // This is because:
    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether "scrollHeight" value is latest or not.
    // - That code only run on "scroll" event.
    // - That means, on every "scroll" event, if the "scrollHeight" value is not latest, we will skip modifying the stickiness.
    // - That means, if the user "focus" to an element that cause the scroll view to scroll to the bottom, the user agent will fire "scroll" event.
    //   Since the "scrollHeight" is not latest value, this "scroll" event will be ignored and stickiness will not be modified.
    // - That means, if the user "focus" to a newly added element that is at the end of the scroll view, the "scroll to bottom" button will continue to show.
    //
    // Repro in Chrome:
    // 1. Fill up a scroll view
    // 2. Scroll up, the "scroll to bottom" button should show up
    // 3. Click "Add a button"
    // 4. Click on the scroll view (to pseudo-focus on it)
    // 5. Press TAB, the scroll view will be at the bottom
    //
    // Expect:
    // - The "scroll to bottom" button should be gone.
    if (target) {
      var handleFocus = function handleFocus() {
        return setScrollHeight(target.scrollHeight);
      };

      target.addEventListener('focus', handleFocus, {
        capture: true,
        passive: true
      });
      return function () {
        return target.removeEventListener('focus', handleFocus);
      };
    }
  }, [target]);
  return /*#__PURE__*/_react.default.createElement(_InternalContext.default.Provider, {
    value: internalContext
  }, /*#__PURE__*/_react.default.createElement(_FunctionContext.default.Provider, {
    value: functionContext
  }, /*#__PURE__*/_react.default.createElement(_StateContext.default.Provider, {
    value: stateContext
  }, children, target && /*#__PURE__*/_react.default.createElement(_EventSpy.default, {
    debounce: debounce,
    name: "scroll",
    onEvent: handleScroll,
    target: target
  }), target && scrollTop !== null && /*#__PURE__*/_react.default.createElement(_SpineTo.default, {
    name: "scrollTop",
    onEnd: handleScrollEnd,
    target: target,
    value: scrollTop
  }))));
};

Composer.defaultProps = {
  checkInterval: 100,
  children: undefined,
  debounce: 17,
  mode: undefined,
  nonce: undefined
};
Composer.propTypes = {
  checkInterval: _propTypes.default.number,
  children: _propTypes.default.any,
  debounce: _propTypes.default.number,
  mode: _propTypes.default.oneOf(['bottom', 'top']),
  nonce: _propTypes.default.string
};
var _default = Composer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TY3JvbGxUb0JvdHRvbS9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJNSU5fQ0hFQ0tfSU5URVJWQUwiLCJNT0RFX0JPVFRPTSIsIk1PREVfVE9QIiwiTkVBUl9FTkRfVEhSRVNIT0xEIiwiU0NST0xMX0RFQ0lTSU9OX0RVUkFUSU9OIiwiZW1vdGlvblBvb2wiLCJzZXRJbW1lZGlhdGVJbnRlcnZhbCIsImZuIiwibXMiLCJzZXRJbnRlcnZhbCIsImNvbXB1dGVWaWV3U3RhdGUiLCJtb2RlIiwidGFyZ2V0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsVG9wIiwiYXRCb3R0b20iLCJhdFRvcCIsImF0RW5kIiwiYXRTdGFydCIsImlzRW5kIiwiQ29tcG9zZXIiLCJjaGVja0ludGVydmFsIiwiY2hpbGRyZW4iLCJkZWJvdW5jZSIsIm5vbmNlIiwiaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYiLCJzZXRTY3JvbGxUb3AiLCJzZXRUYXJnZXQiLCJzZXRPZmZzZXRIZWlnaHQiLCJzZXRTY3JvbGxIZWlnaHQiLCJhbmltYXRpbmciLCJzZXRBbmltYXRpbmciLCJzZXRBdEJvdHRvbSIsInNldEF0RW5kIiwic2V0QXRUb3AiLCJzZXRBdFN0YXJ0Iiwic3RpY2t5Iiwic2V0U3RpY2t5Iiwic2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYiLCJvYnNlcnZlU2Nyb2xsUG9zaXRpb24iLCJjdXJyZW50IiwicHVzaCIsInNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiaGFuZGxlU2Nyb2xsRW5kIiwiRGF0ZSIsIm5vdyIsInNjcm9sbFRvIiwiYmVoYXZpb3IiLCJjb25zb2xlIiwid2FybiIsInNjcm9sbFRvQm90dG9tIiwic2Nyb2xsVG9Ub3AiLCJzY3JvbGxUb0VuZCIsIm9wdGlvbnMiLCJzY3JvbGxUb1N0YXJ0Iiwic3RpY2t5QnV0Tm90QXRFbmRTaW5jZSIsInRpbWVvdXQiLCJNYXRoIiwibWF4IiwiY2xlYXJJbnRlcnZhbCIsImhhbmRsZVNjcm9sbCIsInRpbWVTdGFtcExvdyIsIm5leHRPZmZzZXRIZWlnaHQiLCJuZXh0U2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Q2hhbmdlZCIsInNjcm9sbEhlaWdodENoYW5nZWQiLCJhY3R1YWxTY3JvbGxUb3AiLCJmb3JFYWNoIiwib2JzZXJ2ZXIiLCJzdHlsZVRvQ2xhc3NOYW1lIiwiZW1vdGlvbiIsImtleSIsInN0eWxlIiwiY3NzIiwiaW50ZXJuYWxDb250ZXh0IiwiYW5pbWF0aW5nVG9FbmQiLCJzdGF0ZUNvbnRleHQiLCJmdW5jdGlvbkNvbnRleHQiLCJoYW5kbGVGb2N1cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXB0dXJlIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJudW1iZXIiLCJhbnkiLCJvbmVPZiIsInN0cmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsa0JBQWtCLEdBQUcsRUFBM0IsQyxDQUErQjs7QUFDL0IsSUFBTUMsV0FBVyxHQUFHLFFBQXBCO0FBQ0EsSUFBTUMsUUFBUSxHQUFHLEtBQWpCO0FBQ0EsSUFBTUMsa0JBQWtCLEdBQUcsQ0FBM0I7QUFDQSxJQUFNQyx3QkFBd0IsR0FBRyxFQUFqQyxDLENBQXFDO0FBRXJDO0FBQ0E7O0FBQ0EsSUFBTUMsV0FBVyxHQUFHLEVBQXBCOztBQUVBLFNBQVNDLG9CQUFULENBQThCQyxFQUE5QixFQUFrQ0MsRUFBbEMsRUFBc0M7QUFDcENELEVBQUFBLEVBQUU7QUFFRixTQUFPRSxXQUFXLENBQUNGLEVBQUQsRUFBS0MsRUFBTCxDQUFsQjtBQUNEOztBQUVELFNBQVNFLGdCQUFULE9BQXVGO0FBQUEsTUFBM0RDLElBQTJE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O0FBR3RCaEUsRUFBQUEsUUFBUSxFQUFFLEVBSFk7QUFJdEJiLEVBQUFBLElBQUksRUFBRTZFLFNBSmdCO0FBS3RCL0QsRUFBQUEsS0FBSyxFQUFFK0Q7QUFMZSxDQUF4QjtBQVFBbkUsUUFBUSxDQUFDb0UsU0FBVCxHQUFxQjtBQUNuQm5FLEVBQUFBLGFBQWEsRUFBRW9FLG1CQUFVQyxNQUROO0FBRW5CcEUsRUFBQUEsUUFBUSxFQUFFbUUsbUJBQVVFLEdBRkQ7QUFHbkJwRSxFQUFBQSxRQUFRLEVBQUVrRSxtQkFBVUMsTUFIRDtBQUluQmhGLEVBQUFBLElBQUksRUFBRStFLG1CQUFVRyxLQUFWLENBQWdCLENBQUMsUUFBRCxFQUFXLEtBQVgsQ0FBaEIsQ0FKYTtBQUtuQnBFLEVBQUFBLEtBQUssRUFBRWlFLG1CQUFVSTtBQUxFLENBQXJCO2VBUWV6RSxRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUVtb3Rpb24gZnJvbSAnY3JlYXRlLWVtb3Rpb24nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgY3JlYXRlQ1NTS2V5IGZyb20gJy4uL2NyZWF0ZUNTU0tleSc7XG5pbXBvcnQgRXZlbnRTcHkgZnJvbSAnLi4vRXZlbnRTcHknO1xuaW1wb3J0IEZ1bmN0aW9uQ29udGV4dCBmcm9tICcuL0Z1bmN0aW9uQ29udGV4dCc7XG5pbXBvcnQgSW50ZXJuYWxDb250ZXh0IGZyb20gJy4vSW50ZXJuYWxDb250ZXh0JztcbmltcG9ydCBTcGluZVRvIGZyb20gJy4uL1NwaW5lVG8nO1xuaW1wb3J0IFN0YXRlQ29udGV4dCBmcm9tICcuL1N0YXRlQ29udGV4dCc7XG5cbmNvbnN0IE1JTl9DSEVDS19JTlRFUlZBTCA9IDE3OyAvLyAxIGZyYW1lXG5jb25zdCBNT0RFX0JPVFRPTSA9ICdib3R0b20nO1xuY29uc3QgTU9ERV9UT1AgPSAndG9wJztcbmNvbnN0IE5FQVJfRU5EX1RIUkVTSE9MRCA9IDE7XG5jb25zdCBTQ1JPTExfREVDSVNJT05fRFVSQVRJT04gPSAzNDsgLy8gMiBmcmFtZXNcblxuLy8gV2UgcG9vbCB0aGUgZW1vdGlvbiBvYmplY3QgYnkgbm9uY2UuXG4vLyBUaGlzIGlzIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBnZW5lcmF0ZSB0b28gbWFueSB1bm5lZWRlZCA8c3R5bGU+IHRhZ3MuXG5jb25zdCBlbW90aW9uUG9vbCA9IHt9O1xuXG5mdW5jdGlvbiBzZXRJbW1lZGlhdGVJbnRlcnZhbChmbiwgbXMpIHtcbiAgZm4oKTtcblxuICByZXR1cm4gc2V0SW50ZXJ2YWwoZm4sIG1zKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVZpZXdTdGF0ZSh7IG1vZGUsIHRhcmdldDogeyBvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gfSkge1xuICBjb25zdCBhdEJvdHRvbSA9IHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCAtIG9mZnNldEhlaWdodCA8IE5FQVJfRU5EX1RIUkVTSE9MRDtcbiAgY29uc3QgYXRUb3AgPSBzY3JvbGxUb3AgPCBORUFSX0VORF9USFJFU0hPTEQ7XG5cbiAgY29uc3QgYXRFbmQgPSBtb2RlID09PSBNT0RFX1RPUCA/IGF0VG9wIDogYXRCb3R0b207XG4gIGNvbnN0IGF0U3RhcnQgPSBtb2RlICE9PSBNT0RFX1RPUCA/IGF0VG9wIDogYXRCb3R0b207XG5cbiAgcmV0dXJuIHtcbiAgICBhdEJvdHRvbSxcbiAgICBhdEVuZCxcbiAgICBhdFN0YXJ0LFxuICAgIGF0VG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRW5kKHNjcm9sbFRvcCwgbW9kZSkge1xuICByZXR1cm4gKG1vZGUgPT09IE1PREVfVE9QICYmIHNjcm9sbFRvcCA9PT0gMCkgfHwgKG1vZGUgPT09IE1PREVfQk9UVE9NICYmIHNjcm9sbFRvcCA9PT0gJzEwMCUnKTtcbn1cblxuY29uc3QgQ29tcG9zZXIgPSAoeyBjaGVja0ludGVydmFsLCBjaGlsZHJlbiwgZGVib3VuY2UsIG1vZGUsIG5vbmNlIH0pID0+IHtcbiAgbW9kZSA9IG1vZGUgPT09IE1PREVfVE9QID8gTU9ERV9UT1AgOiBNT0RFX0JPVFRPTTtcblxuICBjb25zdCBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgW3Njcm9sbFRvcCwgc2V0U2Nyb2xsVG9wXSA9IHVzZVN0YXRlKG1vZGUgPT09IE1PREVfVE9QID8gMCA6ICcxMDAlJyk7XG4gIGNvbnN0IFt0YXJnZXQsIHNldFRhcmdldF0gPSB1c2VTdGF0ZShudWxsKTtcblxuICAvLyBJbnRlcm5hbCBjb250ZXh0XG4gIGNvbnN0IFtvZmZzZXRIZWlnaHQsIHNldE9mZnNldEhlaWdodF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3Njcm9sbEhlaWdodCwgc2V0U2Nyb2xsSGVpZ2h0XSA9IHVzZVN0YXRlKDApO1xuXG4gIC8vIFN0YXRlIGNvbnRleHRcbiAgY29uc3QgW2FuaW1hdGluZywgc2V0QW5pbWF0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2F0Qm90dG9tLCBzZXRBdEJvdHRvbV0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2F0RW5kLCBzZXRBdEVuZF0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2F0VG9wLCBzZXRBdFRvcF0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2F0U3RhcnQsIHNldEF0U3RhcnRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3RpY2t5LCBzZXRTdGlja3ldID0gdXNlU3RhdGUodHJ1ZSk7XG5cbiAgLy8gSGlnaC1yYXRlIHN0YXRlIGNvbnRleHRcbiAgY29uc3Qgc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYgPSB1c2VSZWYoW10pO1xuICBjb25zdCBvYnNlcnZlU2Nyb2xsUG9zaXRpb24gPSB1c2VDYWxsYmFjayhcbiAgICBmbiA9PiB7XG4gICAgICBzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZi5jdXJyZW50LnB1c2goZm4pO1xuICAgICAgdGFyZ2V0ICYmIGZuKHsgc2Nyb2xsVG9wOiB0YXJnZXQuc2Nyb2xsVG9wIH0pO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQ6IHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzIH0gPSBzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzY3JvbGxQb3NpdGlvbk9ic2VydmVycy5pbmRleE9mKGZuKTtcblxuICAgICAgICB+aW5kZXggJiYgc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBbc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYsIHRhcmdldF1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVTY3JvbGxFbmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYuY3VycmVudCA9IERhdGUubm93KCk7XG4gICAgc2V0QW5pbWF0aW5nKGZhbHNlKTtcbiAgICBzZXRTY3JvbGxUb3AobnVsbCk7XG4gIH0sIFtpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZiwgc2V0QW5pbWF0aW5nLCBzZXRTY3JvbGxUb3BdKTtcblxuICAvLyBGdW5jdGlvbiBjb250ZXh0XG4gIGNvbnN0IHNjcm9sbFRvID0gdXNlQ2FsbGJhY2soXG4gICAgKHNjcm9sbFRvcCwgeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIC8vIFN0b3AgYW55IGV4aXN0aW5nIGFuaW1hdGlvblxuICAgICAgICBoYW5kbGVTY3JvbGxFbmQoKTtcblxuICAgICAgICAvLyBKdW1wIHRvIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHNjcm9sbFRvcCA9PT0gJzEwMCUnID8gdGFyZ2V0LnNjcm9sbEhlaWdodCAtIHRhcmdldC5vZmZzZXRIZWlnaHQgOiBzY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbTogUGxlYXNlIHNldCBcImJlaGF2aW9yXCIgd2hlbiBjYWxsaW5nIFwic2Nyb2xsVG9cIi4gSW4gZnV0dXJlIHZlcnNpb25zLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIGNoYW5nZWQgZnJvbSBzbW9vdGggc2Nyb2xsaW5nIHRvIGRpc2NyZXRlIHNjcm9sbGluZyB0byBhbGlnbiB3aXRoIEhUTUwgU3RhbmRhcmQuJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgc2V0QW5pbWF0aW5nKHRydWUpO1xuICAgICAgICBzZXRTY3JvbGxUb3Aoc2Nyb2xsVG9wKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtoYW5kbGVTY3JvbGxFbmQsIHNldEFuaW1hdGluZywgc2V0U2Nyb2xsVG9wLCB0YXJnZXRdXG4gICk7XG5cbiAgY29uc3Qgc2Nyb2xsVG9Cb3R0b20gPSB1c2VDYWxsYmFjayhcbiAgICAoeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGJlaGF2aW9yICE9PSAnc21vb3RoJyAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ3JlYWN0LXNjcm9sbC10by1ib3R0b206IFBsZWFzZSBzZXQgXCJiZWhhdmlvclwiIHdoZW4gY2FsbGluZyBcInNjcm9sbFRvQm90dG9tXCIuIEluIGZ1dHVyZSB2ZXJzaW9ucywgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2lsbCBiZSBjaGFuZ2VkIGZyb20gc21vb3RoIHNjcm9sbGluZyB0byBkaXNjcmV0ZSBzY3JvbGxpbmcgdG8gYWxpZ24gd2l0aCBIVE1MIFN0YW5kYXJkLidcbiAgICAgICAgKTtcblxuICAgICAgc2Nyb2xsVG8oJzEwMCUnLCB7IGJlaGF2aW9yOiBiZWhhdmlvciB8fCAnc21vb3RoJyB9KTtcbiAgICB9LFxuICAgIFtzY3JvbGxUb11cbiAgKTtcblxuICBjb25zdCBzY3JvbGxUb1RvcCA9IHVzZUNhbGxiYWNrKFxuICAgICh7IGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgYmVoYXZpb3IgIT09ICdzbW9vdGgnICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbTogUGxlYXNlIHNldCBcImJlaGF2aW9yXCIgd2hlbiBjYWxsaW5nIFwic2Nyb2xsVG9Ub3BcIi4gSW4gZnV0dXJlIHZlcnNpb25zLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIGNoYW5nZWQgZnJvbSBzbW9vdGggc2Nyb2xsaW5nIHRvIGRpc2NyZXRlIHNjcm9sbGluZyB0byBhbGlnbiB3aXRoIEhUTUwgU3RhbmRhcmQuJ1xuICAgICAgICApO1xuXG4gICAgICBzY3JvbGxUbygwLCB7IGJlaGF2aW9yOiBiZWhhdmlvciB8fCAnc21vb3RoJyB9KTtcbiAgICB9LFxuICAgIFtzY3JvbGxUb11cbiAgKTtcblxuICBjb25zdCBzY3JvbGxUb0VuZCA9IHVzZUNhbGxiYWNrKFxuICAgICh7IGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgYmVoYXZpb3IgIT09ICdzbW9vdGgnICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbTogUGxlYXNlIHNldCBcImJlaGF2aW9yXCIgd2hlbiBjYWxsaW5nIFwic2Nyb2xsVG9FbmRcIi4gSW4gZnV0dXJlIHZlcnNpb25zLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIGNoYW5nZWQgZnJvbSBzbW9vdGggc2Nyb2xsaW5nIHRvIGRpc2NyZXRlIHNjcm9sbGluZyB0byBhbGlnbiB3aXRoIEhUTUwgU3RhbmRhcmQuJ1xuICAgICAgICApO1xuXG4gICAgICBjb25zdCBvcHRpb25zID0geyBiZWhhdmlvcjogYmVoYXZpb3IgfHwgJ3Ntb290aCcgfTtcblxuICAgICAgbW9kZSA9PT0gTU9ERV9UT1AgPyBzY3JvbGxUb1RvcChvcHRpb25zKSA6IHNjcm9sbFRvQm90dG9tKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW21vZGUsIHNjcm9sbFRvQm90dG9tLCBzY3JvbGxUb1RvcF1cbiAgKTtcblxuICBjb25zdCBzY3JvbGxUb1N0YXJ0ID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb1N0YXJ0XCIuIEluIGZ1dHVyZSB2ZXJzaW9ucywgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2lsbCBiZSBjaGFuZ2VkIGZyb20gc21vb3RoIHNjcm9sbGluZyB0byBkaXNjcmV0ZSBzY3JvbGxpbmcgdG8gYWxpZ24gd2l0aCBIVE1MIFN0YW5kYXJkLidcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgYmVoYXZpb3I6IGJlaGF2aW9yIHx8ICdzbW9vdGgnIH07XG5cbiAgICAgIG1vZGUgPT09IE1PREVfVE9QID8gc2Nyb2xsVG9Cb3R0b20ob3B0aW9ucykgOiBzY3JvbGxUb1RvcChvcHRpb25zKTtcbiAgICB9LFxuICAgIFttb2RlLCBzY3JvbGxUb0JvdHRvbSwgc2Nyb2xsVG9Ub3BdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBsZXQgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IGZhbHNlO1xuXG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0SW1tZWRpYXRlSW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAoc3RpY2t5ICYmIHRhcmdldCAmJiAhY29tcHV0ZVZpZXdTdGF0ZSh7IG1vZGUsIHRhcmdldCB9KS5hdEVuZCkge1xuICAgICAgICAgIGlmICghc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSkge1xuICAgICAgICAgICAgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChEYXRlLm5vdygpIC0gc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA+IFNDUk9MTF9ERUNJU0lPTl9EVVJBVElPTikge1xuICAgICAgICAgICAgLy8gUXVpcmtzOiBJbiBGaXJlZm94LCBhZnRlciB1c2VyIHNjcm9sbCBkb3duLCBGaXJlZm94IGRvIHR3byB0aGluZ3M6XG4gICAgICAgICAgICAvLyAgICAgICAgIDEuIFNldCB0byBhIG5ldyBcInNjcm9sbFRvcFwiXG4gICAgICAgICAgICAvLyAgICAgICAgIDIuIEZpcmUgXCJzY3JvbGxcIiBldmVudFxuICAgICAgICAgICAgLy8gICAgICAgICBGb3Igd2hhdCB3ZSBvYnNlcnZlZCwgIzEgaXMgZmlyZWQgYWJvdXQgMjBtcyBiZWZvcmUgIzIuIFRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgdGhpcyBzdGlja3lDaGVja1RpbWVvdXQgaXMgYmVpbmcgc2NoZWR1bGVkIGJldHdlZW4gMSBhbmQgMi5cbiAgICAgICAgICAgIC8vICAgICAgICAgVGhhdCBtZWFucywgaWYgd2UganVzdCBsb29rIGF0ICMxIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgc2Nyb2xsLCB3ZSB3aWxsIGFsd2F5cyBzY3JvbGwsIGluIG9wcG9zZSB0byB0aGUgdXNlcidzIGludGVudGlvbi5cbiAgICAgICAgICAgIC8vIFJlcHJvOiBPcGVuIEZpcmVmb3gsIHNldCBjaGVja0ludGVydmFsIHRvIGEgbG93ZXIgbnVtYmVyLCBhbmQgdHJ5IHRvIHNjcm9sbCBieSBkcmFnZ2luZyB0aGUgc2Nyb2xsIGhhbmRsZXIuIEl0IHdpbGwganVtcCBiYWNrLlxuXG4gICAgICAgICAgICAhYW5pbWF0aW5nICYmIHNjcm9sbFRvRW5kKHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgICAgICAgICAgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgubWF4KE1JTl9DSEVDS19JTlRFUlZBTCwgY2hlY2tJbnRlcnZhbCkgfHwgTUlOX0NIRUNLX0lOVEVSVkFMKTtcblxuICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwodGltZW91dCk7XG4gICAgfVxuICB9LCBbYW5pbWF0aW5nLCBjaGVja0ludGVydmFsLCBtb2RlLCBzY3JvbGxUb0VuZCwgc3RpY2t5LCB0YXJnZXRdKTtcblxuICBjb25zdCBoYW5kbGVTY3JvbGwgPSB1c2VDYWxsYmFjayhcbiAgICAoeyB0aW1lU3RhbXBMb3cgfSkgPT4ge1xuICAgICAgLy8gQ3VycmVudGx5LCB0aGVyZSBhcmUgbm8gcmVsaWFibGUgd2F5IHRvIGNoZWNrIGlmIHRoZSBcInNjcm9sbFwiIGV2ZW50IGlzIHRyaWdnZXIgZHVlIHRvXG4gICAgICAvLyB1c2VyIGdlc3R1cmUsIHByb2dyYW1tYXRpYyBzY3JvbGxpbmcsIG9yIENocm9tZS1zeW50aGVzaXplZCBcInNjcm9sbFwiIGV2ZW50IHRvIGNvbXBlbnNhdGUgc2l6ZSBjaGFuZ2UuXG4gICAgICAvLyBUaHVzLCB3ZSB1c2Ugb3VyIGJlc3QtZWZmb3J0IHRvIGd1ZXNzIGlmIGl0IGlzIHRyaWdnZXJlZCBieSB1c2VyIGdlc3R1cmUsIGFuZCBkaXNhYmxlIHN0aWNreSBpZiBpdCBpcyBoZWFkaW5nIHRvd2FyZHMgdGhlIHN0YXJ0IGRpcmVjdGlvbi5cblxuICAgICAgaWYgKHRpbWVTdGFtcExvdyA8PSBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFNpbmNlIHdlIGRlYm91bmNlIFwic2Nyb2xsXCIgZXZlbnQsIHRoaXMgaGFuZGxlciBtaWdodCBiZSBjYWxsZWQgYWZ0ZXIgc3BpbmVUby5vbkVuZCAoYS5rLmEuIGFydGlmaWNpYWwgc2Nyb2xsaW5nKS5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIGlnbm9yZSBkZWJvdW5jZWQgZXZlbnQgZmlyZWQgYWZ0ZXIgc2Nyb2xsRW5kLCBiZWNhdXNlIHdpdGhvdXQgc2tpcHBpbmcgdGhlbSwgdGhlIHVzZXJJbml0aWF0ZWRTY3JvbGwgY2FsY3VsYXRlZCBiZWxvdyB3aWxsIG5vdCBiZSBhY2N1cmF0ZS5cbiAgICAgICAgLy8gVGh1cywgb24gYSBmYXN0IG1hY2hpbmUsIGFkZGluZyBlbGVtZW50cyBzdXBlciBmYXN0IHdpbGwgbG9zZSB0aGUgXCJzdGlja2luZXNzXCIuXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHsgYXRCb3R0b20sIGF0RW5kLCBhdFN0YXJ0LCBhdFRvcCB9ID0gY29tcHV0ZVZpZXdTdGF0ZSh7IG1vZGUsIHRhcmdldCB9KTtcblxuICAgICAgICBzZXRBdEJvdHRvbShhdEJvdHRvbSk7XG4gICAgICAgIHNldEF0RW5kKGF0RW5kKTtcbiAgICAgICAgc2V0QXRTdGFydChhdFN0YXJ0KTtcbiAgICAgICAgc2V0QXRUb3AoYXRUb3ApO1xuXG4gICAgICAgIC8vIENocm9tZSB3aWxsIGVtaXQgXCJzeW50aGV0aWNcIiBzY3JvbGwgZXZlbnQgaWYgdGhlIGNvbnRhaW5lciBpcyByZXNpemVkIG9yIGFuIGVsZW1lbnQgaXMgYWRkZWRcbiAgICAgICAgLy8gV2UgbmVlZCB0byBpZ25vcmUgdGhlc2UgXCJzeW50aGV0aWNcIiBldmVudHNcbiAgICAgICAgLy8gUmVwcm86IEluIHBsYXlncm91bmQsIHByZXNzIDQtMS01LTEtMSAoc21hbGwsIGFkZCBvbmUsIG5vcm1hbCwgYWRkIG9uZSwgYWRkIG9uZSlcbiAgICAgICAgLy8gICAgICAgIE5vbWF0dGVyIGhvdyBmYXN0IG9yIHNsb3cgdGhlIHNlcXVlbmNlIGlzIGJlaW5nIHByZXNzZWQsIGl0IHNob3VsZCBzdGlsbCBzdGljayB0byB0aGUgYm90dG9tXG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0OiBuZXh0T2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQ6IG5leHRTY3JvbGxIZWlnaHQgfSA9IHRhcmdldDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0SGVpZ2h0Q2hhbmdlZCA9IG5leHRPZmZzZXRIZWlnaHQgIT09IG9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0Q2hhbmdlZCA9IG5leHRTY3JvbGxIZWlnaHQgIT09IHNjcm9sbEhlaWdodDtcblxuICAgICAgICBvZmZzZXRIZWlnaHRDaGFuZ2VkICYmIHNldE9mZnNldEhlaWdodChuZXh0T2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgc2Nyb2xsSGVpZ2h0Q2hhbmdlZCAmJiBzZXRTY3JvbGxIZWlnaHQobmV4dFNjcm9sbEhlaWdodCk7XG5cbiAgICAgICAgLy8gU3RpY2t5IG1lYW5zOlxuICAgICAgICAvLyAtIElmIGl0IGlzIHNjcm9sbGVkIHByb2dyYW1hdGljYWxseSwgd2UgYXJlIHN0aWxsIGluIHN0aWNreSBtb2RlXG4gICAgICAgIC8vIC0gSWYgaXQgaXMgc2Nyb2xsZWQgYnkgdGhlIHVzZXIsIHRoZW4gc3RpY2t5IG1lYW5zIGlmIHdlIGFyZSBhdCB0aGUgZW5kXG5cbiAgICAgICAgLy8gT25seSB1cGRhdGUgc3RpY2tpbmVzcyBpZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIG5vdCBkdWUgdG8gc3ludGhldGljIHNjcm9sbCBkb25lIGJ5IENocm9tZVxuICAgICAgICAhb2Zmc2V0SGVpZ2h0Q2hhbmdlZCAmJlxuICAgICAgICAgICFzY3JvbGxIZWlnaHRDaGFuZ2VkICYmXG4gICAgICAgICAgc2V0U3RpY2t5KFxuICAgICAgICAgICAgLy8gV2UgYXJlIHN0aWNreSBpZiB3ZSBhcmUgYW5pbWF0aW5nIHRvIHRoZSBlbmQsIG9yIHdlIGFyZSBhbHJlYWR5IGF0IHRoZSBlbmQuXG4gICAgICAgICAgICAvLyBXZSBjYW4gYmUgXCJhbmltYXRpbmcgYnV0IG5vdCBzdGlja3lcIiBieSBjYWxsaW5nIFwic2Nyb2xsVG8oMTAwKVwiIHdoZXJlIHRoZSBjb250YWluZXIgc2Nyb2xsSGVpZ2h0IGlzIDIwMHB4LlxuICAgICAgICAgICAgKGFuaW1hdGluZyAmJiBpc0VuZChzY3JvbGxUb3AsIG1vZGUpKSB8fCBhdEVuZFxuICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gSWYgbm8gc2Nyb2xsVG9wIGlzIHNldCAobm90IGluIHByb2dyYW1tYXRpYyBzY3JvbGxpbmcgbW9kZSksIHdlIHNob3VsZCBzZXQgXCJhbmltYXRpbmdcIiB0byBmYWxzZVxuICAgICAgICAvLyBcImFuaW1hdGluZ1wiIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBcInN0aWNreVwiIHByb3BlcnR5XG4gICAgICAgIHNjcm9sbFRvcCA9PT0gbnVsbCAmJiBzZXRBbmltYXRpbmcoZmFsc2UpO1xuXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wOiBhY3R1YWxTY3JvbGxUb3AgfSA9IHRhcmdldDtcblxuICAgICAgICBzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZi5jdXJyZW50LmZvckVhY2gob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIoeyBzY3JvbGxUb3A6IGFjdHVhbFNjcm9sbFRvcCB9KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBhbmltYXRpbmcsXG4gICAgICBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZixcbiAgICAgIG1vZGUsXG4gICAgICBvZmZzZXRIZWlnaHQsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZixcbiAgICAgIHNjcm9sbFRvcCxcbiAgICAgIHNldEFuaW1hdGluZyxcbiAgICAgIHNldEF0Qm90dG9tLFxuICAgICAgc2V0QXRFbmQsXG4gICAgICBzZXRBdFN0YXJ0LFxuICAgICAgc2V0QXRUb3AsXG4gICAgICBzZXRPZmZzZXRIZWlnaHQsXG4gICAgICBzZXRTY3JvbGxIZWlnaHQsXG4gICAgICBzZXRTdGlja3ksXG4gICAgICB0YXJnZXRcbiAgICBdXG4gICk7XG5cbiAgY29uc3Qgc3R5bGVUb0NsYXNzTmFtZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGVtb3Rpb24gPVxuICAgICAgZW1vdGlvblBvb2xbbm9uY2VdIHx8IChlbW90aW9uUG9vbFtub25jZV0gPSBjcmVhdGVFbW90aW9uKHsga2V5OiBgcmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbS0tY3NzLSR7Y3JlYXRlQ1NTS2V5KCl9YCwgbm9uY2UgfSkpO1xuXG4gICAgcmV0dXJuIHN0eWxlID0+IGVtb3Rpb24uY3NzKHN0eWxlKSArICcnO1xuICB9LCBbbm9uY2VdKTtcblxuICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBvYnNlcnZlU2Nyb2xsUG9zaXRpb24sXG4gICAgICBvZmZzZXRIZWlnaHQsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzZXRUYXJnZXQsXG4gICAgICBzdHlsZVRvQ2xhc3NOYW1lXG4gICAgfSksXG4gICAgW29ic2VydmVTY3JvbGxQb3NpdGlvbiwgb2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQsIHNldFRhcmdldCwgc3R5bGVUb0NsYXNzTmFtZV1cbiAgKTtcblxuICBjb25zdCBhbmltYXRpbmdUb0VuZCA9IGFuaW1hdGluZyAmJiBpc0VuZChzY3JvbGxUb3AsIG1vZGUpO1xuXG4gIGNvbnN0IHN0YXRlQ29udGV4dCA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGFuaW1hdGluZyxcbiAgICAgIGFuaW1hdGluZ1RvRW5kLFxuICAgICAgYXRCb3R0b20sXG4gICAgICBhdEVuZCxcbiAgICAgIGF0U3RhcnQsXG4gICAgICBhdFRvcCxcbiAgICAgIG1vZGUsXG4gICAgICBzdGlja3lcbiAgICB9KSxcbiAgICBbYW5pbWF0aW5nLCBhbmltYXRpbmdUb0VuZCwgYXRCb3R0b20sIGF0RW5kLCBhdFN0YXJ0LCBhdFRvcCwgbW9kZSwgc3RpY2t5XVxuICApO1xuXG4gIGNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHNjcm9sbFRvLFxuICAgICAgc2Nyb2xsVG9Cb3R0b20sXG4gICAgICBzY3JvbGxUb0VuZCxcbiAgICAgIHNjcm9sbFRvU3RhcnQsXG4gICAgICBzY3JvbGxUb1RvcFxuICAgIH0pLFxuICAgIFtzY3JvbGxUbywgc2Nyb2xsVG9Cb3R0b20sIHNjcm9sbFRvRW5kLCBzY3JvbGxUb1N0YXJ0LCBzY3JvbGxUb1RvcF1cbiAgKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFdlIG5lZWQgdG8gdXBkYXRlIHRoZSBcInNjcm9sbEhlaWdodFwiIHZhbHVlIHRvIGxhdGVzdCB3aGVuIHRoZSB1c2VyIGRvIGEgZm9jdXMgaW5zaWRlIHRoZSBib3guXG4gICAgLy9cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2U6XG4gICAgLy8gLSBJbiBvdXIgY29kZSB0aGF0IG1pdGlnYXRlIENocm9tZSBzeW50aGV0aWMgc2Nyb2xsaW5nLCB0aGF0IGNvZGUgd2lsbCBsb29rIGF0IHdoZXRoZXIgXCJzY3JvbGxIZWlnaHRcIiB2YWx1ZSBpcyBsYXRlc3Qgb3Igbm90LlxuICAgIC8vIC0gVGhhdCBjb2RlIG9ubHkgcnVuIG9uIFwic2Nyb2xsXCIgZXZlbnQuXG4gICAgLy8gLSBUaGF0IG1lYW5zLCBvbiBldmVyeSBcInNjcm9sbFwiIGV2ZW50LCBpZiB0aGUgXCJzY3JvbGxIZWlnaHRcIiB2YWx1ZSBpcyBub3QgbGF0ZXN0LCB3ZSB3aWxsIHNraXAgbW9kaWZ5aW5nIHRoZSBzdGlja2luZXNzLlxuICAgIC8vIC0gVGhhdCBtZWFucywgaWYgdGhlIHVzZXIgXCJmb2N1c1wiIHRvIGFuIGVsZW1lbnQgdGhhdCBjYXVzZSB0aGUgc2Nyb2xsIHZpZXcgdG8gc2Nyb2xsIHRvIHRoZSBib3R0b20sIHRoZSB1c2VyIGFnZW50IHdpbGwgZmlyZSBcInNjcm9sbFwiIGV2ZW50LlxuICAgIC8vICAgU2luY2UgdGhlIFwic2Nyb2xsSGVpZ2h0XCIgaXMgbm90IGxhdGVzdCB2YWx1ZSwgdGhpcyBcInNjcm9sbFwiIGV2ZW50IHdpbGwgYmUgaWdub3JlZCBhbmQgc3RpY2tpbmVzcyB3aWxsIG5vdCBiZSBtb2RpZmllZC5cbiAgICAvLyAtIFRoYXQgbWVhbnMsIGlmIHRoZSB1c2VyIFwiZm9jdXNcIiB0byBhIG5ld2x5IGFkZGVkIGVsZW1lbnQgdGhhdCBpcyBhdCB0aGUgZW5kIG9mIHRoZSBzY3JvbGwgdmlldywgdGhlIFwic2Nyb2xsIHRvIGJvdHRvbVwiIGJ1dHRvbiB3aWxsIGNvbnRpbnVlIHRvIHNob3cuXG4gICAgLy9cbiAgICAvLyBSZXBybyBpbiBDaHJvbWU6XG4gICAgLy8gMS4gRmlsbCB1cCBhIHNjcm9sbCB2aWV3XG4gICAgLy8gMi4gU2Nyb2xsIHVwLCB0aGUgXCJzY3JvbGwgdG8gYm90dG9tXCIgYnV0dG9uIHNob3VsZCBzaG93IHVwXG4gICAgLy8gMy4gQ2xpY2sgXCJBZGQgYSBidXR0b25cIlxuICAgIC8vIDQuIENsaWNrIG9uIHRoZSBzY3JvbGwgdmlldyAodG8gcHNldWRvLWZvY3VzIG9uIGl0KVxuICAgIC8vIDUuIFByZXNzIFRBQiwgdGhlIHNjcm9sbCB2aWV3IHdpbGwgYmUgYXQgdGhlIGJvdHRvbVxuICAgIC8vXG4gICAgLy8gRXhwZWN0OlxuICAgIC8vIC0gVGhlIFwic2Nyb2xsIHRvIGJvdHRvbVwiIGJ1dHRvbiBzaG91bGQgYmUgZ29uZS5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBjb25zdCBoYW5kbGVGb2N1cyA9ICgpID0+IHNldFNjcm9sbEhlaWdodCh0YXJnZXQuc2Nyb2xsSGVpZ2h0KTtcblxuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMsIHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzKTtcbiAgICB9XG4gIH0sIFt0YXJnZXRdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbnRlcm5hbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2ludGVybmFsQ29udGV4dH0+XG4gICAgICA8RnVuY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtmdW5jdGlvbkNvbnRleHR9PlxuICAgICAgICA8U3RhdGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtzdGF0ZUNvbnRleHR9PlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICB7dGFyZ2V0ICYmIDxFdmVudFNweSBkZWJvdW5jZT17ZGVib3VuY2V9IG5hbWU9XCJzY3JvbGxcIiBvbkV2ZW50PXtoYW5kbGVTY3JvbGx9IHRhcmdldD17dGFyZ2V0fSAvPn1cbiAgICAgICAgICB7dGFyZ2V0ICYmIHNjcm9sbFRvcCAhPT0gbnVsbCAmJiAoXG4gICAgICAgICAgICA8U3BpbmVUbyBuYW1lPVwic2Nyb2xsVG9wXCIgb25FbmQ9e2hhbmRsZVNjcm9sbEVuZH0gdGFyZ2V0PXt0YXJnZXR9IHZhbHVlPXtzY3JvbGxUb3B9IC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9TdGF0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L0Z1bmN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L0ludGVybmFsQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbkNvbXBvc2VyLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2hlY2tJbnRlcnZhbDogMTAwLFxuICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICBkZWJvdW5jZTogMTcsXG4gIG1vZGU6IHVuZGVmaW5lZCxcbiAgbm9uY2U6IHVuZGVmaW5lZFxufTtcblxuQ29tcG9zZXIucHJvcFR5cGVzID0ge1xuICBjaGVja0ludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgZGVib3VuY2U6IFByb3BUeXBlcy5udW1iZXIsXG4gIG1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ2JvdHRvbScsICd0b3AnXSksXG4gIG5vbmNlOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb3NlcjtcbiJdfQ==